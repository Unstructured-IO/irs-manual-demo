[
  {
    "element_id": "57c80547a4fb7190d2719c112b3ccd74",
    "text": "Department of the Treasury Internal Revenue Service",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "f0b6df287a6d3ad46239cb9c6d9995ce",
    "text": "This transmits revised Internal Revenue Manual (IRM) 2.5.12, Systems Development, Design Techniques and Deliverables. This IRM was developed to describe techniques for analyzing, designing, and modeling system development software designs.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "996c4ca6b9da6daadbbf090188d98c17",
    "text": "Manual Transmittal signature, changed the title from Acting, Chief Information Officer signature to Chief Information Officer for Nancy A. Sieger.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "e87644e6d5a85615b8df0380cba77a55",
    "text": "Chief Information Officer for Nancy A. Sieger. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "ba5ec51d07a4ac0e951608704431d59a",
    "text": ")",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "fcf1806fbdb42d656b086bed975c8956",
    "text": "), Updated the role and responsibilities of the Customer Service Director (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "ba5ec51d07a4ac0e951608704431d59a",
    "text": ")",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "21d54c78c0abf561c944c5ea48725f12",
    "text": ", Added resource “The Gang of Four (G",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "df2b9231b1554702ba840fbda8994437",
    "text": ") Design Patterns Reference. Learning Object-Oriented Design & Programming Version",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "946197ec23637640d36cf24ea9590103",
    "text": ", January",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "d03502c43d74a30b936740a9517dc4ea",
    "text": ",",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "ba5ec51d07a4ac0e951608704431d59a",
    "text": ")",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "4ad3ee80854319e287b1a9293c62e43f",
    "text": ", Added System and Software Developer’s Best Practice Overview (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "ba5ec51d07a4ac0e951608704431d59a",
    "text": ")",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "2ebb225f7163ca3dac9f0053c254944e",
    "text": "), Added IRS system development and software development teams have many responsibilities, for example:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "23bd427c85bc308f1ab533bb85c6b93a",
    "text": "2.5.12.1.3 (7), Updated the role and responsibilities of the Customer Service Director",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "b3a0b2f7bbd5e444c1051aa9b66be550",
    "text": "2.5.12.2, Added System and Software Developer’s Best Practice Overview",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "b83a0fc163d34e195cae714cd5bbc6cf",
    "text": "2.5.12.2 (1), Added IRS system development and software development teams have many responsibilities, for example:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "b3de9ba07ca5090f1eca880944964ff9",
    "text": "Gathering requirements from stakeholders Analyze, implement current and future system and software programs Mitigate risks for future product changes Implementing and updating Enterprise Life Cycle documentation (artifacts) Creating design and test plans Establishing the design and deployment of enhancements to the current IRS Perform maintenance procedures for software programs",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "923b2d9f2237afdf84d02be0edf00050",
    "text": "2.5.12.2.1 (1), Added The goal of the application architecture section of the EA is to deﬁne a set of architectural patterns from which projects may select in order to build and deploy their applications in a manner that is consistent with the objectives of the IRS as an enterprise. Projects can choose from a limited set of application architecture patterns to build application systems.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "8972621f093c1e6171c792d33ae3231d",
    "text": "2.5.12.2.1 (2), Added Projects are expected to develop their own design level approaches, and documentation based on the architecture guidelines provided in the Enterprise Architecture, included updated EA hyperlink",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "e962eb5e140f3fa886eeda33d0ac082e",
    "text": "2.5.12.2.1 (9), Corrected the word “work ﬂow” to “workﬂow”",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "1478dd4968956739ad81e8755ed32dd8",
    "text": "Added explanation During 1994 four authors: Eric Gamma, Richard Helm, Ralph Johnson and John Vlissides who are jointly known as the “Gang of Four ”(GOF) published a book titled Design Patterns - Elements of Reusable Object-Oriented Software which started the concept of Design Pattern in Software Development. Design patterns provide an industry standard approach to solving recurring problems standard terminology and signiﬁcance to each scenario",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "527b403e6350e35af3f47054d410d11d",
    "text": "2.5.12.3.8 (1) (a - z) Added Software Design Patterns - Best Practices for Developers",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "854fad418b998c04af15c657e659784f",
    "text": "The best practices for developers using Design Patterns are as follows:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 1
    }
  },
  {
    "element_id": "294699863475e0da6d28133c13f28e8a",
    "text": "Behavioral Patterns (Chain of Responsibility)",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 2
    }
  },
  {
    "element_id": "fc3cef637e467b33107211da35c9bc6e",
    "text": "Use this pattern when: You need to process a notiﬁcation using a hierarchical chain of objects Not every observer is created equally For Chain of Responsibility Pattern implementation see",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 2
    }
  },
  {
    "element_id": "cb6df7641143315bd6aed650cbe7d6e2",
    "text": "Chain of Responsibility Pattern Implementation",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 2
    }
  },
  {
    "element_id": "da790ee21347018602a4d856685b96c1",
    "text": "c. Behavioral Patterns (Iterator) - Use this pattern when: You want to access the elements of a collection without having to know any internal details of the collection You are dealing with a collection of objects You are mixing collection types and need to access them in a standard way d. For Iterator Pattern implementation see Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 2
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 2
    }
  },
  {
    "element_id": "be92dbbee8ee6f57460367d3d5f15134",
    "text": "Iterator Pattern Implementation",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 2
    }
  },
  {
    "element_id": "2d94b533d1c879c6c36181f4e527be45",
    "text": "A Create a class Iterator that implements Iterator • Give the class a local variable to store what is in the col- lection (array, vector, etc) • Add a local variable to keep track of where you are in the collection • Add the following methods: “next”, “hasNext”, and “remove” • The method “hasNext” returns a Boolean (true if not at the end of the collection) • The method “next” returns the succeeding item from the collection The method“ remove” takes something out of the collection",
    "type": "UncategorizedText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 2
    }
  },
  {
    "element_id": "3d70ba708e822cd371a74df139dfb71a",
    "text": "e. Behavioral Patterns (Observer) - Use this pattern when: You have a group that needs to know when something happens (the subject lets the observers know when something has happened) You need to send notiﬁcations to a series of objects You need to be able to modify who is observing at runtime f. For Observer Pattern implementation see Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 2
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 2
    }
  },
  {
    "element_id": "e7ac0786668e0ff0f02b62bd04f45ff6",
    "text": ":",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 2
    }
  },
  {
    "element_id": "e6581373e4b10423e56c4b597b149b51",
    "text": "Note: Deﬁnes the skeleton of an algorithm leaving some steps to subclasses; however, if every step needs to be customized then this pattern is pointless",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 3
    }
  },
  {
    "element_id": "db4c452c35e0a1b91f7811381f9ae734",
    "text": "Use this pattern when: You have an algorithm that is made up of multiple steps, and you want to customize some those steps If you have steps that are shared between various implementations of the algorithm h. For Template Pattern implementation do as follows: Deﬁne abstract class with ﬁnal method that calls all steps (functions) Deﬁne default behavior for steps in abstract class (public methods, not necessarily ﬁnal) Add conditions to steps if necessary Extend abstract class, override method for steps that are different i. Creational Patterns (Builder)",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 3
    }
  },
  {
    "element_id": "5d212c55699dec04517cdffd001f16da",
    "text": "Note: You no longer have control over the algorithm. The steps need to be customizable.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 3
    }
  },
  {
    "element_id": "9620b007b6ee8e9a8ca63c3b35341da9",
    "text": "Builder Pattern Implementation",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 3
    }
  },
  {
    "element_id": "cb4cf8637d3dcf81c3e8213e6acb786d",
    "text": "D. Individual classes need a class variable of itself that is set in the public class Buildable call E. Use an Arra",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "60a02bfa40ebcd119e821827119eab75",
    "text": "ist or some other method to store the order of the actions set by the client (using the add/remove methods).",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "331df62d857db7789595e829487baeb1",
    "text": "Note: Use to separate out parts of the code that are changing frequently and encapsulating it in its own object (Connection objects, etc.)",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "94154d2e24640d461ebc7c9b970b9f8b",
    "text": "Circumstances have gotten decentralized enough that many programmers who subclass your factory class are overriding it so much that they’re changing it substantially For Factory Pattern implementation do as follows: Build an abstract class (your base clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "cee7987b20873ac87755f9cb56a84a99",
    "text": "actory) Give your base “clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "810ed1bc45b7f740b327433d3434dd19",
    "text": "actory” any necessary abstract methods that must be implemented Create speciﬁc extensions of the “clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "a5943870abe6a52cecc017045a6efa78",
    "text": "actory” to meet the needs m. Creational Patterns (Flyweight) -",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "dcb651287548c1e30ad90d813c6f8683",
    "text": "Note: Decompose large objects into generic, smaller objects that can be conﬁgured at runtime to appear as the large objects. This can save on system resources.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "bd885253f31857e0b89beba4d5934891",
    "text": "The system has large, resource intensive objects, and you need to make the system less resource intensive n. For Flyweight Pattern implementation do as follows: Create a class that contains only the data you might need (modeled after the larger class) Ensure you have created multiple constructors for the class (to set initial values based on the model of the data you need). Instead of setting everything, set only what is going to be used(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "9d008aaffa9d32728cbbf5c96bebbc24",
    "text": ")Create your class as a singleton to ensure that only one instance of the Flyweight class is in existence. o. Creational Patterns (Singleton) -",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "e4c7ebb201d214eea3060f2787b80b00",
    "text": "Note: To save on resources, you can select certain classes to be set up so that only one instance of your class exists.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "1b0526c4e7bba976b7570cbd744a04d1",
    "text": "Use this pattern when: You need to restrict the number of objects created because you want the share the data in those objects You need to restrict resource usage (instead of creating numbers of large objects without limit)(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "a8bdb5c5137f865dea914a0f8a95ea33",
    "text": ")You need a sensitive object whose data shouldn’t be accessed by multiple instances such a registry p. For Singleton Pattern implementation do as follows: Create your class ﬁle with a static variable of the type of the class itself Ensure the variable is initialized to a new instance of the class ﬁle Ensure you that have created a public static synchronized method returning an instance of your class (ge",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "868f5937485cb05dd0ef299ac054eb86",
    "text": "nstance())",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "1b0526c4e7bba976b7570cbd744a04d1",
    "text": "Use this pattern when: You need to restrict the number of objects created because you want the share the data in those objects You need to restrict resource usage (instead of creating numbers of large objects without limit)(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "88b1523d7d88933b58b8f7313aef5eaa",
    "text": ")You need a sensitive object whose data shouldn’t be accessed by multiple instances such as a registry",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "e3220995bb2bef956193fb71075a4847",
    "text": "For Singleton Pattern implementation do as follows: Create your class ﬁle with a static variable of the type of the class itself Ensure the variable is initialized to a new instance of the class ﬁle Ensure you that have created a public static synchronized method returning an instance of your class (ge",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "6cef8c7eeffcb3ff964bac6f9971b687",
    "text": "nstance()) Ensure you that have created the ge",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "057b1017d13f6d19436c53b24408d426",
    "text": "nstance() method return the static variable",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "4f95145313db28e9964c66bc07e36fe1",
    "text": "you that have created the getInstance() method return the static variable",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 4
    }
  },
  {
    "element_id": "2612eacfb8a5c7ab57760fb0bc55cfff",
    "text": "Creational Patterns (Strategy) :",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 5
    }
  },
  {
    "element_id": "8f83675b7ee79b86d4823fe24a341522",
    "text": "Note: Separate out volatile code into algorithms that contain a complete task.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 5
    }
  },
  {
    "element_id": "50087372da67813ed07f792e12600d85",
    "text": "Use this pattern when: Volatile code exist that can be separated out of your application for easy maintenance You need to avoid confusing how to handle a task by having to split implementation code over several inherited classes You need to change the algorithm that you use for a task at runtime For Strategy Pattern implementation do as follows: Build an Interface to ensure all algorithms use the same methods All algorithms must implement the Interface The class must have a variable of the Interface; set using the speciﬁc algorithm needed the instance of the class",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 5
    }
  },
  {
    "element_id": "148448ddc5ec668e44cfc98b614b9443",
    "text": "Note: Done with a “setInterface” method so that the algorithm changes at runtime.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 5
    }
  },
  {
    "element_id": "6360577f1a336d1b3f4573d84f329b8c",
    "text": "Structural Patterns (Adapter)",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 5
    }
  },
  {
    "element_id": "d9959a03f66bae093e01ae0fb76fd8bb",
    "text": "Note: When you need to make incompatible objects talk to another, you use the exposed methods of one class to feed a secondary class, which then feeds the data into the second object’s exposed methods.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 5
    }
  },
  {
    "element_id": "b59b49dcabadd86fdc7c615a22e653c1",
    "text": "You need to ﬁx the interfaces between two objects without having to change the objects directly (common in store-bought stuff) If what the object exposes isn’t what you need, add an adapter to build what you need When you have legacy code that can’t be changed For Adapter Pattern implementation do as follows: Deﬁne an Interface to the second class Deﬁne a clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 5
    }
  },
  {
    "element_id": "a9bc25488314c078744aeb7db6590e85",
    "text": "dapter class using the interface This class needs to store the ﬁrst class as a variable Build code that gets the ﬁrst class values and adapts them to the second class values Structural Patterns (Composites) - Use this pattern when: You want to create a tree-like structure and access the leaves in the same way as the branches e.g., organization chart You are working with a collection of objects in a tree-like structure You are working with XML For Composites Pattern implementation see",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 5
    }
  },
  {
    "element_id": "8010bc069d6d42ac2e84cbcc613b3128",
    "text": "A. Create an abstract class that has an add method to add(abstract class) and a get Iterator method (to return an iterator in branch/ leaf implementations), but return nothing here. B. Include any other methods that need to exist in the concrete classes C. Create any leafs for the tree that extends the abstract class D. Build an Iterator class for the leaf to return on the get Iterator method E. Create any branches that extends the abstract class F. Build an Iterator class for the branches",
    "type": "UncategorizedText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 5
    }
  },
  {
    "element_id": "a730ff4356913b04a995ee028d8dc0f1",
    "text": "As branches and leaves are both children of the abstract class, you can create a collection to hold them (and the branch can hold the leaf)",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "669901c6908132f4cdf34a371a8bb511",
    "text": "When you call the other methods you deﬁned, it will call them for everything in the tree (assuming your method (like print()) uses an iterator to go through everything)",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "fa308494b0ee4bee0cc565bccca3dd2b",
    "text": "Note: Use wrapper code to extend core code (wrap your class in another class to give it new/ extended functionality).",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "a468f7abe2db27b0bae5f3b0800b854b",
    "text": "You want to “decorate” the results of something in a class with something additional without having to modify the base class for all instances For Decorator Pattern implementation do as follows: Build an abstract class that extends your original class (clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "a82a12009b00e265231d093989155878",
    "text": "ecorator) that deﬁnes method(s) that must exist in all derived classes Derived class (extends clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "c82ad37dd7319affa7d1a6c9aca1ec03",
    "text": "ecorator) must have local variable to hold base class (set with constructor)(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "ce56b8b9f7cc8b7d8a5538d8180ebe45",
    "text": ")Decorator class calls method from base class, and extends it in some fashion (class.descrip- tion() + decorator.description()) Structural Patterns (Facade) -",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "22d93003e8c6d6168e5d31fe91c9b9cc",
    "text": "Note: Provides a wrapper to make original code more workable",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "591739251aa981d08d11067e1799d83d",
    "text": "A class interface is too hard to manipulate The code is poorly encapsulated You need the code to do “x, y, z” without a lot of intermediate steps You can’t rewrite the code to make it easier For Facade Pattern implementation do as follows: Façade class wraps the difficult class (like a Decorator) Make a simple method to do what is needed with the difficult class Provide methods to access the difficult classes simple methods",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "6b5a049caf7fdbf3d002d5908a848044",
    "text": "2.5.12.3.9.1 (2), Corrected hyperlink for REPO Model Driven Requirements",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "c347d81f70c503ef65f058151cc857f2",
    "text": "), Corrected hyperlink for REPO Model",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "79f2a6eae66ec756220fc716ec31118f",
    "text": "), Included punctuation",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "42e8dbbc65f67cfcc4c27f8ec9624893",
    "text": "a b c), Corrected unbolded content Added Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "777f35d4c98663990b8affb52edbd9cb",
    "text": ", Software Design Principles Added Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "0f0c62f03e8d11c0f007bbacdfe808ef",
    "text": ", Top-down Design Approach Added Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "2e1fe5ef737838ef4e269160c0d87281",
    "text": ", Bottom-up Approach Added Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "cc7a1c374c3f5d69b029b76c97a1db9d",
    "text": ", Illustrates Heuristic Evaluation Added Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "1fb96979dd1f6cf07c37654e508a90e6",
    "text": ", Illustrates Module Coupling Added Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "7f9db9fbecf70b063c692f223a06f2c1",
    "text": ", Iterator Pattern Implementation",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "9f4ab28c4be7a5f8eddd32176c827bcb",
    "text": "Added Figure 2.5.12-1, Software Design Principles",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 6
    }
  },
  {
    "element_id": "8fa7e8787e39e2b27aab59df9e72f039",
    "text": "Added Figure 2.5.12-11, Illustration of Object-Oriented Design (OOD) Example",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "9194f7ba02fcd5768b62e7d383e3c20f",
    "text": "Added Figure 2.5.12-12, Illustrates Hierarchical Structure Chart",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "ccefb7f3f4ddabf0623fda5594f40a5b",
    "text": "Added Figure 2.5.12-14, Data Flow Diagram that resulted from Transform Analysis",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "f9d364b9ff91f0bd4d14ba875fe7cc99",
    "text": "Added Figure 2.5.12-15, Illustrates First-Level Module Factoring",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "44f7bda1450573ebda77a10e2a9f50ad",
    "text": "Added Figure 2.5.12-17, Illustrates Transaction-Centered System Data Flow Diagram",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "32cb476474a8e46bf6d99a0e8d605cfd",
    "text": "Added Figure 2.5.12-18, Illustration of Transaction Processor",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "087774b889499fabf4b2d337fdc5cc4d",
    "text": "Added Figure 2.5.12-19, Illustration of Module Naming Conventions",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "af30ff919436f1cf35717658e1fcf2d4",
    "text": "Added Figure 2.5.12-20, Illustration of Module Numbering",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "ecb648da99b3d2e93a69e240a81f5245",
    "text": "Added Figure 2.5.12-21, Illustration of Multi-Page Structure Charts",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "ad73f47eaf4ef41d5841f2060de075e2",
    "text": "Added Figure 2.5.12-22, Illustration of Multi-Page Structure Chart 1",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "6a421a683a4a123ba902eefab3dd7283",
    "text": "Added Figure 2.5.12-23, Illustration of Multi-Page Structure Chart 2",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "9514a70d38b8fce95e84286c78a34eb3",
    "text": "Added Figure 2.5.12-24, Illustration of Module Connections",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "aa41062d19207de069abd9e7c4b8af58",
    "text": "Added Figure 2.5.12-25, Illustration of Module Calls",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "25adc475cd38648f8ead26a9aa46f45a",
    "text": "Added Figure 2.5.12-26, Illustration of Module Iteration",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "899a3656b26199145bc92240c3ca8b1e",
    "text": "Added Figure 2.5.12-27, Illustration of Lexical Inclusion",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "a246acccd01578ec75dfbea45d025625",
    "text": "Added Figure 2.5.12-30, Illustration of RANGE-TABLE is common to modules 1 and 3",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "778f27024e1ed09d6b1201ab590a5ab9",
    "text": "Added Figure 2.5.12-32, Illustration of Structure Chart with Labeled Parameters",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "590605862d88f500b88e802fb61686a4",
    "text": "EFFECT ON OTHER DOCUMENTS",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "07885c2a7454a8cf16e41e8b6bb04358",
    "text": "IRM 2.5.12 dated 06-11- 2020 is superseded, and supplements IRM 2.5.1 System Development and IRM 2.5.3 System Development, Programming and Source Code Standards.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 7
    }
  },
  {
    "element_id": "1e40feedb6d8e174d473a369b3da23fd",
    "text": "AUDIENCE",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 8
    }
  },
  {
    "element_id": "5bfe2e54d9bc84b5de344aa6eb0bc545",
    "text": "The audience intended for this transmittal is personnel responsible for engineering, developing, or maintaining Agency software systems identiﬁed in the Enterprise Architecture. This engineering, development, and maintenance include duties performed by government employees, contractors, and organizations having contractual arrangements with the Internal Revenue Service (IRS).",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 8
    }
  },
  {
    "element_id": "a9360e0212a4d173581c91da68494d02",
    "text": "Table of Contents",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 9
    }
  },
  {
    "element_id": "7ea6384ea076b589f463694b9f0f2220",
    "text": "Example of a Structure Chart Example of Page",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 10
    }
  },
  {
    "element_id": "57aff64d73cb7e1ab385091e5a7ce4da",
    "text": "of a Structure Chart using a Parameter Table Contents and Format of Analysis/Design Cross-Reference List Acronym/Terms Terms/Deﬁnitions",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 10
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "4af895f742909200c299d4da811b77c1",
    "text": ") Scope - This IRM is a guidance for structured design techniques that involves the description, speciﬁcation, and hierarchical arrangement of software compo- nents designed to be small, easily managed, independent modules in terms of their inputs and outputs. Structured design describes a set of classic design methodologies. These design ideas work for a large class of problems. The original structured design idea, stepwise reﬁnement, requires decomposing of the problem from the top down, focusing on the control ﬂow of the solution. It also relates closely to some of the architectures: the main program-subroutine and pipe-and-ﬁlter architectures. Modular decomposition is the immediate precursor to the modern object-oriented methodologies and introduced the ideas of encapsulation and information hiding. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "189198baa4f28766ab8c809b11be2b9b",
    "text": ") Structured Design - This describes a set of classic design methodologies that work for a large class of problems. The design concept behind stepwise reﬁne- ment, is to decompose the problem from the top down, focusing on the control ﬂow of the solution. It also pertains to some of the architectures, the main program subroutine, and pipe-and-ﬁlter architectures. Modular decomposition the predecessor to object-oriented methodologies, and initiated the concepts encapsulation and information hiding. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "db1c77200fde73b529bbb9d562e0e5a1",
    "text": ") Structured Programming and Design Concept - This provides the software designer with a foundation from which more of the following methods can be applied: a. Abstraction - Act or process of representing essential features without including the background details or explanations. b. Control Hierarchy - A program structure that represents the organization of a program component and implied a hierarchy of control. c. Data Structure - Description of the logical relationship between individual elements of data. d. Modularity - Software architecture is divided into elements called modules. e. Software Architecture - Construct of the software and the ways in which that structure provides conceptual integrity for a system. f. Reﬁnement - Use a notation that’s natural to the problem space. Avoid using a programming language for description. Each reﬁnement implies several design decisions based on a set of design criteria. These criteria include efficiency of time and space, clarity, and regularity of structure (simplicity). Reﬁnement can be accomplished in two ways: top down or bottom-up. g. Information Hiding - Modules must be designed so that information contained within a module is inaccessible to modules that do not have a need for the information. h. Structural Partitioning - This program structure can be divided horizon- tally and vertically. Horizontal partitions deﬁne separate branches of modular hierarchy for each major program function. Vertical partitioning pertains to work that is distributed top down in the program structure. i. Top Down/Stepwise Reﬁnement - Characterized by moving from a general description of the problem to more detailed statements of what individual modules or routines do. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "11a85d6bc4c199dd0892fc0cabcb5656",
    "text": ") Software Design and Structure Objectives - All software designs must reﬂect the following expectations: and Deliverables",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "3660315a9af3df255d8f19ab077e4797",
    "text": "page",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "c89b89f4cdf48aab7617de5cf895a35e",
    "text": "Scope - This IRM is a guidance for structured design techniques that involves the description, speciﬁcation, and hierarchical arrangement of software compo- nents designed to be small, easily managed, independent modules in terms their inputs and outputs. Structured design describes a set of classic design methodologies. These design ideas work for a large class of problems. The original structured design idea, stepwise reﬁnement, requires decomposing of the problem from the top down, focusing on the control ﬂow of the solution. It also relates closely to some of the architectures: the main program-subroutine and pipe-and-ﬁlter architectures. Modular decomposition is the immediate precursor to the modern object-oriented methodologies and introduced the ideas of encapsulation and information hiding.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "c006592addc689dd662074da88c5f546",
    "text": ") Program Scope and Objectives (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "4af895f742909200c299d4da811b77c1",
    "text": ") Scope - This IRM is a guidance for structured design techniques that involves the description, speciﬁcation, and hierarchical arrangement of software compo- nents designed to be small, easily managed, independent modules in terms of their inputs and outputs. Structured design describes a set of classic design methodologies. These design ideas work for a large class of problems. The original structured design idea, stepwise reﬁnement, requires decomposing of the problem from the top down, focusing on the control ﬂow of the solution. It also relates closely to some of the architectures: the main program-subroutine and pipe-and-ﬁlter architectures. Modular decomposition is the immediate precursor to the modern object-oriented methodologies and introduced the ideas of encapsulation and information hiding. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "189198baa4f28766ab8c809b11be2b9b",
    "text": ") Structured Design - This describes a set of classic design methodologies that work for a large class of problems. The design concept behind stepwise reﬁne- ment, is to decompose the problem from the top down, focusing on the control ﬂow of the solution. It also pertains to some of the architectures, the main program subroutine, and pipe-and-ﬁlter architectures. Modular decomposition the predecessor to object-oriented methodologies, and initiated the concepts encapsulation and information hiding. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "5234254a5129554b5d05de9d211ed0e2",
    "text": ") Structured Programming and Design Concept - This provides the software designer with a foundation from which more of the following methods can be applied: a. Abstraction - Act or process of representing essential features without including the background details or explanations. b. Control Hierarchy - A program structure that represents the organization of a program component and implied a hierarchy of control. c. Data Structure - Description of the logical relationship between individual elements of data. d. Modularity - Software architecture is divided into elements called modules. e. Software Architecture - Construct of the software and the ways in which",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "587b97be093ee2aa1847724354952e47",
    "text": "designer with a foundation from which more of the following methods can be applied: a. Abstraction",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "6a630251331c8e746035f4c242deb46e",
    "text": "Act or process of representing essential features without including the background details or explanations. b. Control Hierarchy",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "f0d644d24c0d102051d77bb00a32d1d7",
    "text": "A program structure that represents the organization of a program component and implied a hierarchy of control. c. Data Structure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "9ff9108ed91c5d700ea115b7772bedc7",
    "text": "Description of the logical relationship between individual elements of data. d. Modularity",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "f63025131d98068efc2218171d63f0d6",
    "text": "Software architecture is divided into elements called modules. e. Software Architecture",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "74cf3f35f255e90109aa3414b255db51",
    "text": "Construct of the software and the ways in which that structure provides conceptual integrity for a system. f. Reﬁnement",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "df6ec9cb8639996c5e723d36680d662e",
    "text": "Use a notation that’s natural to the problem space. Avoid using a programming language for description. Each reﬁnement implies several design decisions based on a set of design criteria. These criteria include efficiency of time and space, clarity, and regularity of structure (simplicity). Reﬁnement can be accomplished in two ways: top down or bottom",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "eb3a572be3f07cf9495b01a4ba7594d2",
    "text": "up. g. Information Hiding",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "345d99b99a001a4ad134c98d353dd9b0",
    "text": "Modules must be designed so that information contained within a module is inaccessible to modules that do not have a need for the information. h. Structural Partitioning",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "8d5c7a1f2101e93d425be62db8a0ad03",
    "text": "This program structure can be divided horizon",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "db6886badd776f768d5d166c5a41a6df",
    "text": "tally and vertically. Horizontal partitions deﬁne separate branches of modular hierarchy for each major program function. Vertical partitioning pertains to work that is distributed top down in the program structure. i. Top Down/Stepwise Reﬁnement",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "ddfd6c308f107fd5de883b230fa3b097",
    "text": "Characterized by moving from a general description of the problem to more detailed statements of what individual modules or routines do. Software Design and Structure Objectives",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "70c195320c24d73d349a0d13a1a87d00",
    "text": "All software designs must reﬂect the following expectations:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 11
    }
  },
  {
    "element_id": "7ebb4708090356e2701bfbd637b06092",
    "text": "a. Compatibility: The software must be designed for interoperability with another product i.e., backward compatibility with an older version of the same product. b. Extensibility: An internal structure and dataﬂow that is minimally or not affected by new or modiﬁed functionality e.g., refactoring or modifying original source code. When adding new capabilities, you must not create major changes to the underlying architecture. c. Fault-tolerance: The software must be resistant to component failure, and have the ability to recover if failure does occur. d. Maintainability: Ease of bug ﬁxes or code modiﬁcation which is normally a combination of modularity and extensibility processes. e. Modularity: Independent software components leading to better main- tainability i.e., the components can be implemented and tested in isolation. f. Performance: Software must perform all tasks within a timeframe that acceptable for IRS: users, management, and stakeholders without overex- tending memory limits creating lag-time of the application system. g. Portability: Application software should be reusable across a number different conditions e.g., processor types, hardware platforms, (including clients, servers, network connectivity devices, input and output devices) and environments. h. Reliability/Robust: This is the primary goal in software quality design and structure. The software must be failure-free, able to perform the required function(s), and within the timeframe speciﬁed by IRS leadership/management. Software reliability affects the complete system’s reliability. A complete system includes all of the associated equipment, facilities, material, computer programs, ﬁrmware, technical documenta- tion, services, and personnel required for operations and support to the intended environment. i. Reusability: The software must have the capability of using some or all aspects of preexisting software in other projects with minimal or no code modiﬁcations. j. High Scalability: The software must be able to handle increased loads, and maintain its performance. k. Security: The software must adhere to the Federal Information Security Management Act (FISMA) standards, FIPS Pub",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 12
    }
  },
  {
    "element_id": "227f8ca9a60973bc6c8cce1d1131e52f",
    "text": ", OWASP standards, IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 12
    }
  },
  {
    "element_id": "7c8fae46667fac760c9629ac9024c8d4",
    "text": "Security, Privacy and Assurance, Information Technology, Policy and Guidance, withstand agency regression testing, Ap",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 12
    }
  },
  {
    "element_id": "bab8d7dfacb70a642d56f088c32f6524",
    "text": "can testing, and any additional Federal application security standards and/or IRS security requirements for application vulnerabilities. l. Usability: The software user interface must be usable for all target end- users or audience. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 12
    }
  },
  {
    "element_id": "85dd833719c5d2dbdac7b9f262c17523",
    "text": ") Purpose: This manual establishes standards, guidelines, and other controls designing software. This manual describes techniques for structuring a program and specifying the modules that constitute the program structure. manual is also distributed to promote the development of software systems that are easy to understand, change, and maintain. For system development purposes, these controls may be used with any approved life cycle e.g., System Development Life Cycle (SDLC) and Enterprise Life Cycle (ELC). guidelines, standards, techniques, and other controls in this manual apply to software developed for the Internal Revenue Service. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 12
    }
  },
  {
    "element_id": "374c5f73eecf6683da1d725ce23d5bf2",
    "text": ") Audience: All IRS personnel responsible for engineering, developing, or main- taining agency software systems identiﬁed in the Enterprise Architecture.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 12
    }
  },
  {
    "element_id": "f96747c3542394248a841f09315b3547",
    "text": "Systems Development Internal Revenue Manual Cat. No.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 12
    }
  },
  {
    "element_id": "87d2a82689ec9cb6b074c23bf4d2a45e",
    "text": "P (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 12
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 12
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 12
    }
  },
  {
    "element_id": "55e41916be91aca2966d0db044f2ad9a",
    "text": ") Any line marked with",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 12
    }
  },
  {
    "element_id": "ed419cb4f53b7792c646c6469b6d8c78",
    "text": "Audience: All IRS personnel responsible for engineering, developing, or main- taining agency software systems identiﬁed in the Enterprise Architecture.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 12
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "263772a9f67622c54abe92f785b83088",
    "text": ") Policy Owner: The current policy owner is the Acting, Chief Information Officer (CIO). (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "88d8d828db324f8e3b68d7a033a29ad0",
    "text": ") Program Owner: The Technical Integration Organization (TIO) Director is the Program Owner. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "a6dfb724430386a6f1d55c73b01b10c1",
    "text": ") Primary Stakeholders: These can be other areas that are affected by these procedures or have input to the procedures. The affects may include a change in work ﬂow, additional duties, change in established time frames, and similar issues. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "8c4a4038079f516c6ad82d307f499666",
    "text": ") Program Goals: The objective of structured software designs is to provide a better understanding of how software problems will be solved based on a strategy where the problem is broken into several small problems, and each small problem is individually solved until the whole problem is solved. Trans- forming user software requirements into the best possible quality and secure design before implementing the targeted solution. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "ecf6af7737c2daff81a1daba04610707",
    "text": ") Structured programming (modular programming) began during the",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "6a643a0021aa9f70930e4601fa5fa64a",
    "text": "s with the emergence of the ALGOL",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "6201111b83a0cb5b0922cb37cc442b9a",
    "text": "and",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "855f2b502f0a47485948ffb8ed54318f",
    "text": "languages. Before that period, low level machine languages like Fortran and other low level machine languages used goto statements or its equivalent. Goto statements allowed the computer to diverge from the sequential execution of the program instructions, and was considered to be a very profound construction. However, as complex code grew goto statements became more difficult to maintain. During",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "3f30fc52d16e0ffe0e2d2f2abd594501",
    "text": ", Dijkstra recognized the complexity of programs was because of the overuse of the “goto” statement (Dijkstra, E.W., “Got To Considered Harmful”, Communication of the ACM, March",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "15e887f12115b2270c4ee61ea13117e0",
    "text": "). During the early",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "8adb4c8d85fcc0848dc51010c76945b0",
    "text": "s, after Dijkstra demonstrated that any program structure that was created with go statements could be sim- pliﬁed with the sequence-repetition-decision structure Structured Programming was implemented. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "77df2df3945ec64147ca57416de50e69",
    "text": ") The original structured design idea, stepwise reﬁnement was also initiated. This pertains to decomposing the problem from the top down, focusing on the control ﬂow of the solution. It also relates closely to some of the architectures, particularly the main program-subroutine, and pipe-and-ﬁlter architectures. Modular decomposition is the immediate precursor to the modern object- oriented methodologies because it introduces the concepts of encapsulation and information hiding. These ideas are the basics of your design toolbox. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "5cb84cc346fccc5b3bc2715e09d2eecf",
    "text": ") Initially problem solving was taught in a top-down structured manner, where you begin with the problem statement, and attempt to break the problem down into a set of solvable sub-problems. The process continues until each sub- problem is small enough to be either trivial or very easy to solve. This technique is called structured programming and design. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "9152f9d080cb665f1cb7554ed5e6acef",
    "text": ") IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "ae1337a7aa0f2e1279b3b4c550eaad59",
    "text": "System Development, establishes the System Development program for the IRS. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "9152f9d080cb665f1cb7554ed5e6acef",
    "text": ") IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "3f82f5a1b91bf6e9ffaa697fb31dd103",
    "text": "Security, Policy and Guidance (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "9152f9d080cb665f1cb7554ed5e6acef",
    "text": ") IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "143404a6b9a1a55bc721e119019a4c2d",
    "text": "Security, Privacy and Assurance, Privacy and Information Protec- tion (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "695d4430fb67ca6ee4ccd221011aad7e",
    "text": ") Treasury Inspector General Tax Administration (TIGTA) and Deliverables",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "2530f50ca5c5f2f8686f889999050dea",
    "text": "page Internal Revenue Manual",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "3f4c2917223ab3b53b548ec2b1a61a67",
    "text": "Policy Owner: The current policy owner is the Acting, Chief Information Officer",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "bd5393f5df3027bb7fada6751887e914",
    "text": "Structured programming (modular programming) began during the 1950s with the emergence of the ALGOL 58 and 60 languages. Before that period, low level machine languages like Fortran and other low level machine languages used goto statements or its equivalent. Goto statements allowed the computer to diverge from the sequential execution of the program instructions, and was considered to be a very profound construction. However, as complex code grew goto statements became more difficult to maintain. During 1966, Dijkstra recognized the complexity of programs was because of the overuse of the “goto” statement (Dijkstra, E.W., “Got To Considered Harmful”, Communication of the ACM, March 1966). During the early 1970s, after Dijkstra demonstrated that any program structure that was created with go statements could be sim- pliﬁed with the sequence-repetition-decision structure Structured Programming was implemented.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "bf5ffcade67d94eb2cfbfaaff4e6d075",
    "text": "Treasury Inspector General Tax Administration (TIGTA)",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 13
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "973eec18533bcc22e8502509bd4b2f1f",
    "text": ") Federal Information Security Modernization Act (FISMA) of",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "dbc26e2a52a3fa9481e8321ac6b5bcf8",
    "text": ") Taxpayer First Act (TFA) legislation (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "0e526d3cfc2acb322cb367b9822206eb",
    "text": ") Government Accountability Office (GAO) (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "ba5ec51d07a4ac0e951608704431d59a",
    "text": ")",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "3fdc207f9bc6a26c969877e8029116b2",
    "text": "st Century Integrated Digital Experience Act (IDEA), December",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "b2c4a8ddd095504d89477cbb8fb089b6",
    "text": ") Presidential American Technology Council,",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "172c2d930732087cbc6ff656f9d3e4b6",
    "text": ") Director of Office of Management and Budget (OMB) (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "337373511e8817a63207c2da704f01ea",
    "text": ") Secretary of Commerce for Modernization of Federal IT (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "2909ab6552aa5002836dbe7ab196b743",
    "text": ") Federal Information Processing Standards (FIPS) Pub",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "d6a47d52cb43eb86e19b365b23eb52da",
    "text": ", Guidelines for Security of Computer Applications (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "472601d3bfbaaff99a646729498b3af1",
    "text": ") Federal Information Processing Standards (FIPS)",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "49543780c9b14fbb798f065170827bf2",
    "text": ", Minimum Security Re- quirements for Federal Information and Information Systems, March",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "ada5c40ebb0a74478e7fbbec0152d138",
    "text": ") Clinger-Cohen Act (CCA)",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "5af9eec2d890429432b49d86c7d4fbbc",
    "text": ", Title",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "a445ac06e9b4d5947be3b0a7f81a261f",
    "text": ") Information Technology (IT), Cybersecurity : Cybersecurity manages the IT Security program in accordance with the Federal Information Security Man- agement Act with the goal of delivering effective and professional customer service to business units and support functions within the IRS. These proce- dures are done as the following: a. Provide valid risk mitigated solutions to security inquisitions. b. Respond to incidents quickly, and effectively in order to eliminate risks/ threats. c. Ensure all IT security policies and procedures are actively developed, and updated. d. Provide security advice to IRS constituents, and proactively monitor IRS robust security program for any required modiﬁcations or enhancements. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "3fcfb27e3dc043a2cda11b19bf51b4ff",
    "text": ") Applications Development (AD) : AD is responsible for building, testing, deliv- ering, and maintaining integrated information applications systems, e.g., software solutions, to support modernized systems and production environment to achieve the mission and objectives of the Service. Additional, AD is respon- sible for the following: AD works in partnership with customers to improve the quality of and deliver changes to IRS information systems products and services Establishes and maintains rigorous contract and ﬁscal management, oversight, quality assurance, and program risk management processes to ensure that strategic plans and priorities are being met Maintains the effectiveness and enhance the integration of IRS installed base production systems and infrastructure while modernizing core business systems and infrastructure Provides quality assessment/assurance of deliverables and processes (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "56fb81228a431d510558a5a6706605ea",
    "text": ") Application Development’s chain of command is the following: a. Commissioner : Oversees and provides overall strategic direction for IRS. The Commissioner’s and Deputy Commissioner’s main focus is for the IRS’s services programs, enforcement, operations support, and orga- nizations. Additionally, the Commissioner’s vision is to enhance services",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "f96747c3542394248a841f09315b3547",
    "text": "Systems Development Internal Revenue Manual Cat. No.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "87d2a82689ec9cb6b074c23bf4d2a45e",
    "text": "P (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "55e41916be91aca2966d0db044f2ad9a",
    "text": ") Any line marked with",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "51c8de3757316e8d423552b43cdd8d45",
    "text": "Federal Information Processing Standards (FIPS) 200, Minimum Security Re- quirements for Federal Information and Information Systems, March 2006",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "3f6197a152c012196f3c4f42ffb1d3e0",
    "text": "service to business units and support functions within the IRS. These proce",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "eef9526ad287726a55756de9c3715cfe",
    "text": "dures are done as the following: a. Provide valid risk mitigated solutions to security inquisitions. b. Respond to incidents quickly, and effectively in order to eliminate risks/ threats. c. Ensure all IT security policies and procedures are actively developed, and updated. d. Provide security advice to IRS constituents, and proactively monitor robust security program for any required modiﬁcations or enhancements. Applications Development (AD) : AD is responsible for building, testing, ering, and maintaining integrated information applications systems, e.g., software solutions, to support modernized systems and production environment to achieve the mission and objectives of the Service. Additional, AD is respon",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "1f6b98ec22e4bf422baac92709f24381",
    "text": "sible for the following: AD works in partnership with customers to improve the quality of and deliver changes to IRS information systems products and services Establishes and maintains rigorous contract and ﬁscal management, oversight, quality assurance, and program risk management processes to ensure that strategic plans and priorities are being met Maintains the effectiveness and enhance the integration of IRS installed base production systems and infrastructure while modernizing core business systems and infrastructure Provides quality assessment/assurance of deliverables and processes Application Development’s chain of command is the following: a. Commissioner : Oversees and provides overall strategic direction for IRS. The Commissioner’s and Deputy Commissioner’s main focus is the IRS’s services programs, enforcement, operations support, and nizations. Additionally, the Commissioner’s vision is to enhance services",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "c606bfbd1f82c2dbeef14640184b2517",
    "text": "a. Provide valid risk mitigated solutions to security inquisitions. b. Respond to incidents quickly, and effectively in order to eliminate risks/ threats. c. Ensure all IT security policies and procedures are actively developed, and updated. d. Provide security advice to IRS constituents, and proactively monitor IRS robust security program for any required modiﬁcations or enhancements.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 14
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "76b4e742f5147403cd2bfafc6f23e8ac",
    "text": "for the nation’s taxpayers, balancing appropriate enforcement of the nation’s tax laws while respecting taxpayers’ rights. b. Deputy Commissioner, Operation Support (DCOS) : Oversees the op- erations of Agency-Wide Shared Services: Chief Financial Officer, Human Capital Office, Information Technology, Planning Programming and Audit Oversight and Privacy, and Governmental Liaison and Disclosure. c. Chief Information Officer (CIO) : The CIO leads Information Technology, and advises the Commissioner on Information Technology matters, manages all IRS IT resources, and is responsible for delivering and main- taining modernized information systems throughout the IRS. d. Application Development (AD) Associate Chief Information Officer (ACIO) : The AD ACIO reports directly to the CIO; oversees and ensures the quality of: building, unit testing, delivering and maintaining integrated enterprise-wide applications systems to support modernized and legacy systems in the production environment to achieve the mission of the Service. e. Deputy AD Associate CIO (ACIO) : The Deputy AD ACIO reports directly to the AD ACIO, and is responsible for: Leading all strategic priorities to enable the AD Vision, IT Technology Roadmap and the IRS future state Executive planning, and management of the development organiza- tion which ensures all ﬁling season programs are developed, tested, and delivered on-time and within budget (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "292f5db49c9d2c03069c9545f4ac6e78",
    "text": ") AD has the following Domains: a. Compliance Domain b. Corporate Data Domain c. Customer Service Domain d. Data Delivery Service (DDS) Domain e. Delivery Management; Quality Assurance (DMQA) Domain f. Identity & Access Management (IAM) Organization Domain g. Internal Management Domain h. Submission Processing Domain i. Technical Integration Organization (TIO) Domain (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "edd13733689f0f4f99e576c55485d107",
    "text": ") Director, Compliance : Provides executive direction for a wide suite of Compli- ance domain focused applications and oversee the IT Software Development organization to ensure the quality of production ready applications. a. Directs and oversees a uniﬁed cross-divisional approach to compliance strategies needing collaboration pertaining for the following: • Abusive tax avoidance transactions needing a coordinated response • Cross-divisional technical issues • Emerging issues • Service-wide operational procedures (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "8d79daca5bdd00f76d025fd72d5638dc",
    "text": ") Director, AD Corporate Data : Directs and oversees the provisioning of au- thoritative databases, refund identiﬁcation, notice generation, and reporting. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "566de1405b67e5a4a37dcaf9dd526414",
    "text": ") Director, Customer Service : Directs and oversees Customer Service Support for service and communication with internal and external customers and providing taxpayers with self-service online. Services provided are as follows: and Deliverables",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "3660315a9af3df255d8f19ab077e4797",
    "text": "page",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "0bc112af206f46f91860f37e06ee8490",
    "text": "for the nation’s taxpayers, balancing appropriate enforcement of the nation’s tax laws while respecting taxpayers’ rights. b. Deputy Commissioner, Operation Support (DCOS) : Oversees the op",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "68a1c623fdb779b15554d8894c4fbac7",
    "text": "erations of Agency",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "22e94b5075450bd5d0de8079b8b81ce7",
    "text": "Wide Shared Services: Chief Financial Officer, Human Capital Office, Information Technology, Planning Programming and Audit Oversight and Privacy, and Governmental Liaison and Disclosure. c. Chief Information Officer (CIO) : The CIO leads Information Technology, and advises the Commissioner on Information Technology matters, manages all IRS IT resources, and is responsible for delivering and main",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "35de60a1230ff790f0072416edbc944d",
    "text": "taining modernized information systems throughout the IRS. d. Application Development (AD) Associate Chief Information Officer (ACIO) : The AD ACIO reports directly to the CIO; oversees and ensures the quality of: building, unit testing, delivering and maintaining integrated enterprise",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "1087d6f0da77829ebe60618d8c0c0c50",
    "text": "wide applications systems to support modernized and legacy systems in the production environment to achieve the mission of the Service. e. Deputy AD Associate CIO (ACIO) : The Deputy AD ACIO reports directly to the AD ACIO, and is responsible for: Leading all strategic priorities to enable the AD Vision, IT Technology Roadmap and the IRS future state Executive planning, and management of the development organiza",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "bf572417a981e4d369383c89680eb755",
    "text": "tion which ensures all ﬁling season programs are developed, tested, and delivered on",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "8012340d09b889a93bef50241c195aa6",
    "text": "time and within budget",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "98e0b0ab8828cf80d639fce74c91bf79",
    "text": "Directs and oversees a uniﬁed cross-divisional approach to compliance strategies needing collaboration pertaining for the following:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 15
    }
  },
  {
    "element_id": "e80247e08820439694f03e748f50a470",
    "text": "a. Customer Service Domain’s applications and systems provide: Tax law assistance Taxpayer education Access to taxpayer account data Maintenance of modernized information systems that meet the cus- tomer’s needs for researching, updating, analyzing, and managing taxpayer accounts b. Services to internal and external customers are provided through ﬁve primary means: Centralized Contact Centers (for telephone, written, and electronic inquiries)(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "f6efa79cd0408706ce203398b8e57549",
    "text": ")Self-service applications (via the telephone and Internet) Field Assistance (for walk-in assistance) Web Services Management of Taxpayer Accounts (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "3db76770f895cc37a0f3a00983c461a3",
    "text": ") Director, Data Delivery Services : Oversees and ensures the quality of data with repeatable processes in a scalable environment. The Enterprise Data Strategy is to transform DDS into a data centric organization dedicated to deliver Data as a Service (Da",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "d8a29a7c5d96dad34adb42a3aa06b19a",
    "text": ") through: • Innovation - New methods, discoveries • Renovation - Streamline or automate • Motivation - Encourage and enable individuals (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "0d0877f4b7d5a384885d6ea02659b6ed",
    "text": ") Director, Delivery Management & Quality Assurance (DMQA) : • Executes the mission of DMQA by ensuring AD has a coordinated, cross-domain, and cross-organizational approach to delivering AD systems and software applications • Reports to the AD ACIO, and chairs the AD Risk Review Board • Chairperson, Conﬁguration Control Board • Government Sponsor, Conﬁguration Control Board, see IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "24e2207f919782bae6a393a74d32ed57",
    "text": "System Development • For additional information concerning AD roles, see IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "bcafca5f2651b42244b110e94e4477c2",
    "text": ") Director, Identity & Access Management (IAM) Organization : Provides oversight and direction for continual secure online interaction by veriﬁcation and establishing an individual’s identity before providing access to taxpayer information “identity prooﬁng” while staying compliant within federal security requirements. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "57a047653746889fe25b447deb0a7892",
    "text": ") Director, Internal Management : Provides oversight for the builds, tests, eries, refund identiﬁcation, notice generation, and reporting. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "f32fd09f6e394aa7234ed01784733adb",
    "text": ") Director, Submission Processing : Provides oversight to an organization over",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "d03502c43d74a30b936740a9517dc4ea",
    "text": ",",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "65c08702c37d9e99e45444f03947fd3b",
    "text": "employees, comprised of: a headquarters staff responsible for veloping program policies and procedures, ﬁve W&I processing centers, and seven commercially operated lockbox banks. Responsible for the processing more than",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "8a4942bb9949902e0c8af2d2467101e2",
    "text": "million individual and business tax returns through both elec- tronic and paper methods. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "8925f62c52623ac755a738e530aa13e4",
    "text": ") Director, Technical Integration : Provides strategic technical organization oversight ensuring applicable guidance, collaboration, consolidation of integration issues, and quality assurance for the Applications Development portfolio.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "f96747c3542394248a841f09315b3547",
    "text": "Systems Development Internal Revenue Manual Cat. No.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "87d2a82689ec9cb6b074c23bf4d2a45e",
    "text": "P (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "ed858095adc7701dcfcf5473eebbd27d",
    "text": ") Any line marked with is for Official Use",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "81c770afea4965f8bcb5bc569f398518",
    "text": "a. Customer Service Domain’s applications and systems provide: Tax law assistance Taxpayer education Access to taxpayer account data Maintenance of modernized information systems that meet the tomer’s needs for researching, updating, analyzing, and managing taxpayer accounts b. Services to internal and external customers are provided through ﬁve primary means: Centralized Contact Centers (for telephone, written, and electronic inquiries)(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "3ec0fb2f3bf113b436f5612f2c1a8055",
    "text": ")Self-service applications (via the telephone and Internet) Field Assistance (for walk-in assistance) Web Services Management of Taxpayer Accounts",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "dde0b2aeccac874c454f29ad3d46abd2",
    "text": "• Motivation - Encourage and enable individuals (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "0d0877f4b7d5a384885d6ea02659b6ed",
    "text": ") Director, Delivery Management & Quality Assurance (DMQA) : • Executes the mission of DMQA by ensuring AD has a coordinated, cross-domain, and cross-organizational approach to delivering AD systems and software applications • Reports to the AD ACIO, and chairs the AD Risk Review Board • Chairperson, Conﬁguration Control Board • Government Sponsor, Conﬁguration Control Board, see IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "24e2207f919782bae6a393a74d32ed57",
    "text": "System Development • For additional information concerning AD roles, see IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "bcafca5f2651b42244b110e94e4477c2",
    "text": ") Director, Identity & Access Management (IAM) Organization : Provides oversight and direction for continual secure online interaction by veriﬁcation and establishing an individual’s identity before providing access to taxpayer information “identity prooﬁng” while staying compliant within federal security requirements. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "57a047653746889fe25b447deb0a7892",
    "text": ") Director, Internal Management : Provides oversight for the builds, tests, eries, refund identiﬁcation, notice generation, and reporting. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "160f7183c2d7b286745debf58844adbf",
    "text": ") Director, Submission Processing : Provides oversight to an organization of over",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "d03502c43d74a30b936740a9517dc4ea",
    "text": ",",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "65c08702c37d9e99e45444f03947fd3b",
    "text": "employees, comprised of: a headquarters staff responsible for veloping program policies and procedures, ﬁve W&I processing centers, and seven commercially operated lockbox banks. Responsible for the processing more than",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "8a4942bb9949902e0c8af2d2467101e2",
    "text": "million individual and business tax returns through both elec- tronic and paper methods. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "5209d9ab50429e2c3157e53aafcad9f7",
    "text": ") Director, Technical Integration : Provides strategic technical organization oversight ensuring applicable guidance, collaboration, consolidation of technical integration issues, and quality assurance for the Applications Development portfolio.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "6aa343858a355e8987bfecd431629eb6",
    "text": "Executes the mission of DMQA by ensuring AD has a coordinated, cross-domain, and cross-organizational approach to delivering AD systems and software applications Reports to the AD ACIO, and chairs the AD Risk Review Board Chairperson, Conﬁguration Control Board Government Sponsor, Conﬁguration Control Board, see IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "9ec608eb816e8e3b9c240ff7265dc93a",
    "text": "System Development For additional information concerning AD roles, see IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "febbcb2ff16de25bf3c200f9338a6521",
    "text": "Director, Internal Management : Provides oversight for the builds, tests, deliv- eries, refund identiﬁcation, notice generation, and reporting.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 16
    }
  },
  {
    "element_id": "d309269c5f92825b003a1d8d46a5fb29",
    "text": "Quality reviews for application design and structure are conducted and tracked by the AD Quality Assurance domain and the Enterprise Architecture domain.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "9b153d98a4e720dbfef06db4f541df90",
    "text": ") See Exhibit",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "7f503a9a3bcae7d9c5937113b4fe429c",
    "text": "for Terms/Deﬁnitions. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "f2b454b8ea17ce53249c739367b2fa92",
    "text": ") John F. Dooley, Software Development, Design and Coding,",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "18b1749490171a575070b0a28e181e4e",
    "text": ", https:// doi.org/",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "8a5edab282632443219e051e4ade2d1d",
    "text": "/",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "d2e2adf7177b7a8afddbc12d1634cf23",
    "text": "_",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "36cc8cd0e7c3a312b91e4d753a326c64",
    "text": ") NIST Special Publication SP",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "b388a30fbce9f2197d37dc97aaa3a0df",
    "text": ", Revision",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "66e6a3bceec9ce3b5aaaf27d689f3829",
    "text": ", Security Considerations System Development Life Cycle (SDLC) (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "49813cf4465197447639b49da9f01655",
    "text": ") NIST SP",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "1fc5fdcf12723108e9786faf5fbf11a3",
    "text": "Rev",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "28fb03a2134c65645535af698628505b",
    "text": ") IEEE Standard for Information technology, System Design, Software Design Descriptions (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "de0be6ae3bcea86c966fd4c08eb2652f",
    "text": ") IEEE",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "fc5df50d287f0e512fa6d99b3526e692",
    "text": "- ISO/IEC/IEEE International Standard, Systems and software engineering, Software Life Cycle Processes (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "2f4abdc20db9231b2d529cd9498a3d23",
    "text": ") ISO/IEC",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "e7ac0786668e0ff0f02b62bd04f45ff6",
    "text": ":",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "ceee6ad6f15f0832e63f8ad3e886c710",
    "text": "+ - Information Technology, Security Techniques - tion Security (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "0dc151eb157a741ae34035ada1bcd5a1",
    "text": ") Software Reliability Review, The R & M Engineering Journal, Volume",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "70ffd00a2aadfbac3a063b1773769a81",
    "text": ", Number",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "72cb5a83ee9fe1a2260dc3fccdddfdcd",
    "text": ", June",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "f9c18c0cf2f0b1afc916d32211e069b4",
    "text": ") Amoedo, Raphael. Achieving a Mature Software,",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "8d55f733f20b305579fbbb80b6554b93",
    "text": "ISBN: (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "cbda2fa47cc2587c0e16d25c22681b40",
    "text": ") Tutorials Point website, https://www.tutorialspoint.com/software_engineering/ software_requirements.htm . (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "030e59d5b87611a9399c8fc2b410b95f",
    "text": ") Martin, Robert C.. Clean Architecture: A Craftsman’s Guide To Software Structure and Design ,",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "d796c697cb84d014dd46d1e4c707c813",
    "text": "ISBN-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "e7ac0786668e0ff0f02b62bd04f45ff6",
    "text": ":",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "e4b7842e510bcd9e32dc87ebe3400cd7",
    "text": ", ISBN:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "e7ac0786668e0ff0f02b62bd04f45ff6",
    "text": ":",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "d9eb3fa0cce38e6727e78514612d8128",
    "text": "https://www.informit.com (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "6209abf73c83c9d5380f1292d0b00691",
    "text": ") Dooley, John F. Integrated Talent Management (ITM) training - Software opment, Design and Coding: Patterns, Debugging, Unit Testing, and Refactoring, Second Ed.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "bf25a713b41e2b7fdaa4fc80dc742d95",
    "text": ") Java T Point. website Module Coupling: Coupling and Cohesion https:// www.javatpoint.com/software-engineering-coupling-and-cohesion (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "1a1933a847e35efc36758bedad6045a2",
    "text": ") J.F. Dooley, Software Development, Design and Coding, website https://doi.org/",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "8a5edab282632443219e051e4ade2d1d",
    "text": "/",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "d2e2adf7177b7a8afddbc12d1634cf23",
    "text": "_",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "e4b7842e510bcd9e32dc87ebe3400cd7",
    "text": ", ISBN:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "fdd69ba04c199b9256e5627460a7a7e8",
    "text": "Java T Point. website Module Coupling: Coupling and Cohesion https:// www.javatpoint.com/software-engineering-coupling-and-cohesion",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "1e24b3ae247b9a71d7fc7078d9a29cb8",
    "text": "J.F. Dooley, Software Development, Design and Coding, website https://doi.org/ 10.1007/978-1-4842-3153-1_7 , ISBN: 9781484231531",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 17
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "7cdcef3cc2ea94dba57aba8aceacf0e3",
    "text": ") The Gang of Four (G",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "df2b9231b1554702ba840fbda8994437",
    "text": ") Design Patterns Reference. Learning Object-Oriented Design & Programming Version",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "946197ec23637640d36cf24ea9590103",
    "text": ", January",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "d03502c43d74a30b936740a9517dc4ea",
    "text": ",",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "4644ea93fbc6a581bf400517ba3f59ac",
    "text": "http://www.w",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "1ef251f5684e24451c3de0f9ad8af62d",
    "text": "sdesign. com/ (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "c7c530b2d68ebd4478f65468bbbdf86a",
    "text": ") IRS system development and software development teams have many respon- sibilities, for example: • Gathering requirements from stakeholders • Analyze, implement current and future system and software programs • Mitigate risks for future product changes • Implementing and updating Enterprise Life Cycle documentation (artifacts) • Creating design and test plans • Establishing the design and deployment of enhancements to the current IRS architecture • Perform maintenance procedures for software programs (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "eb110174550b097974b765c629c06410",
    "text": ") Because system and software development involves various technical environ- ments and personnel roles, standard best practices must be formulated and consistently used for optimal quality of agency IT product outcomes. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "c04893ad7c95519340cfa3ad0e54446b",
    "text": ") The goal of the application architecture section of the EA is to deﬁne a set of architectural patterns from which projects may select in order to build and deploy their applications in a manner that is consistent with the objectives of the IRS as an enterprise. Projects can choose from a limited set of application architecture patterns to build application systems.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "0933f30ad5bd9046857d88c046e747e2",
    "text": "The Gang of Four (GoF) Design Patterns Reference. Learning Object-Oriented Design & Programming Version 2.0, January 10, 2017 http://www.w3sdesign.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "40e1fc93de561e9b575b063f8806ba23",
    "text": ") Software architecture is the ﬁrst step in producing software design. Software architecture is not operational software. It is a representation that provides as a software engineer, developer or designer with the following advantages: a. Enables the developer to analyze, and see the effectiveness of the design early as stated in requirements. b. Risks are reduced associated with the construction of the software. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "0c2c7c28084d89a68eb7d6a6b36a84c9",
    "text": ") Software design is a process of deﬁning software methods, functions, structure, and interaction of your code so that the resulting functionality will satisfy customer requirements. A good and practical approach to software design is to devise a simplistic design and implementation, and extending/ refactoring it gradually to include more of the requirements. Your software design must include a description of the overall architecture: hardware, databases, and third party frameworks your software will use or interact with, and is the big picture of what is running where and how all the parts interact. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "4a3945e942105a4836058984ae7f5e36",
    "text": ") Software is a collection of executable programming code, associated libraries and documentations. When made for a speciﬁc requirement is called a software product. The process of developing a software product using software engineering principles and methods is called Software Evolution .",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 18
    }
  },
  {
    "element_id": "b9f078e4708044f2004bddfa879b9ca5",
    "text": "Your software design must include all Application Programming Interfaces that are used by your code or by external code that calls your code.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 19
    }
  },
  {
    "element_id": "4786625ed4368d56e897690811a5268d",
    "text": "Your software design must include all Application Programming Interfaces that are used by your code or by external code that calls your code. Regardless of the size of your project or what process is used for your design, all software designs must have speciﬁc characteristics. You must adhere to list of principles as you consider your design. a. Fitness of Purpose : Your design must satisfy the requirements within the constraints of the platform on which the software will be running. Don’t add any new requirements as you go—the customer shall provide the requirements. b. Separation of Concerns (Modularity) : Separate out functional pieces your design cleanly in order to simplify ease of maintenance as in the following:(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 19
    }
  },
  {
    "element_id": "df3f2a7b56d710657860c2adc03446d6",
    "text": ")Identify the parts of your design that are likely to change within accor- dance to your customer’s project requirements e.g., business rules and user interfaces can change. c. Simplicity : Use the “KISS” principle (Keep It Simple and Straightfor- ward), you must keep your design as simple as possible. If needed, add more modules or classes to your design to create more simplicity. Sim- plicity also applies to interfaces between modules or classes. Simple interfaces allow other developers to see the data and control ﬂow in your software design. In agile this is called refactoring . d. Ease of Maintenance : Create a well understood software design so it more ﬂexible to change. Errors occur at all phases of the development process: requirements, analysis, design, coding, and testing. The easier to understand your design, the easier it will be to isolate and ﬁx errors. e. Loose Coupling : Important for isolating changes to modules or classes. When separating your design into modules—or in object-oriented design, into classes—the degree to which the classes depend on each other is called coupling. Tightly coupled modules may share data or pro- cedures. This means that a change in one module is much more likely lead to a required change in the other module. This increases the main- tenance burden, and makes the modules more likely to contain errors. Loosely coupled modules are connected solely by their interfaces. Any data they both needs must be passed between procedures or methods via an interface. Loosely coupled modules hide the details of how they perform opera- tions from other modules sharing only the interfaces. This lightens the maintenance burden because a change to how one class is implemented will not affect how another class operates as long as the interface is unvarying. f. High Cohesion : This is the counterpart of loose coupling. Cohesion within a module is the degree to which the module is self-contained with regard both to the data it holds, and the operations that act on the data. class that has high cohesion has all the data it needs deﬁned within the class template. Any object that is instantiated from the class template is very independent, and just communicates with other objects via the published interface. g. Extensibility : Create your design to allow easier addition of new features e.g., software is never really ﬁnished because after a release of a product the customer normally request additional or modiﬁcation of features.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 19
    }
  },
  {
    "element_id": "d320d07991c966f3c9b81c9590c03226",
    "text": "h. Ease of Portability : Because of various IT platforms within the IRS, software or applications must have the capability of being easily ported other platforms. The issues involved with porting software include: operating system issues, hardware architecture and user interface issues. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "fc0da9ad44d3762a6d673b6b50e7ba2b",
    "text": ") Software design is heuristic, and is done using a set of ever-changing heuris- tics (rule of thumb) that each designer acquires over the course of time. Design and (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "738750983e83adfa0f80e0feedf05989",
    "text": ") Structured design is a technique that involves the description, speciﬁcation, and hierarchical arrangement of software components designed to be small, easily managed, independent modules conceived in terms of their inputs and outputs. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "74eaaf6dbe5779931789876f67d1ee43",
    "text": ") Structure charts and module speciﬁcations are tools used in structured design for documenting the design of a system. A mature software product is software that has all of these features: • Reliability - The software must do what has been designated. • Stable - Software has minimal, if any bugs. • Secure - The software must be designed with concern for vulnerabili- ties, and must be integrated with security safeguards according to federal and industry application security standards: IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "eec2a544d447f4a92c00ab2ed23954b3",
    "text": ", OWASP, and NIST SP",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "1fc5fdcf12723108e9786faf5fbf11a3",
    "text": "Rev",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "f573cbcf59be1d02254ebefcf590109e",
    "text": "• Flexible - The software must be designed in a way that an update or new feature will not break the functionality. • Robust - Must be fail-proof with user input and events. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "63a93d2469b35fa584a28f2351ad308c",
    "text": ") To obtain mature software, the following appropriate development process is required: a. Ensure all software is written with clean code, and is well structured. b. Ensure all software is well tested (Peer testing, Unit test, Integration test, and System test). See IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "0722e71215886662a7c0c4aed87a3660",
    "text": "Testing Standards and Procedures IT Test Policy. c. All software must have Version Control (VC) applied: This is a central server (repository) versioning system that records changes to a ﬁle or of ﬁles over time so that you can recall speciﬁc versions later. The beneﬁts of using version control are listed below: VC has the ability of restoring previous versions of the system VC supports code comparison VC can provide full management of changes VC supports code integration d. Build and automate software deployments. e. Ensure there is a simple process ﬂow between creation and deployment. Processes must be optimized to eliminate bottlenecks to systems. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "046e3a5e200f46f039bf2023e7f21d8c",
    "text": ") Pre-Design Phase - Processes necessary before implementing the Design phase: a. Feasibility Study - An analyst must perform a detailed study focusing on the desired requirements and goals of the organization. This study will determine whether a practical software product can be created based Cost constraints Cost per value and objectives Analyzing the technical aspects of the project for its usability, maintain- ability, productivity, and system integration capability",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "f96747c3542394248a841f09315b3547",
    "text": "Systems Development Internal Revenue Manual Cat. No.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "87d2a82689ec9cb6b074c23bf4d2a45e",
    "text": "P (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "ba5ec51d07a4ac0e951608704431d59a",
    "text": ")",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "0eaa4666101b289ef9c849812eda0357",
    "text": "Software design is heuristic, and is done using a set of ever-changing heuris- tics (rule of thumb) that each designer acquires over the course of time.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "c928f13a7040653342ff0ece57409b9e",
    "text": "Reliability - The software must do what has been designated. Stable - Software has minimal, if any bugs. Secure - The software must be designed with concern for vulnerabili- ties, and must be integrated with security safeguards according to federal and industry application security standards: IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "eec2a544d447f4a92c00ab2ed23954b3",
    "text": ", OWASP, and NIST SP",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "1fc5fdcf12723108e9786faf5fbf11a3",
    "text": "Rev",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "4de3515977a7bd94cf659fa3bc3737d4",
    "text": "Flexible - The software must be designed in a way that an update or new feature will not break the functionality. Robust - Must be fail-proof with user input and events.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "bbabfd48df32330e277bc4f23c907c39",
    "text": "• Robust - Must be fail-proof with user input and events. To obtain mature software, the following appropriate development process is required: a. Ensure all software is written with clean code, and is well structured. b. Ensure all software is well tested (Peer testing, Unit test, Integration test, and System test). See IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "40877d884858a65e54183261fab3d778",
    "text": "Testing Standards and Procedures IT Test Policy. c. All software must have Version Control (VC) applied: This is a central server (repository) versioning system that records changes to a ﬁle or of ﬁles over time so that you can recall speciﬁc versions later. The beneﬁts of using version control are listed below: VC has the ability of restoring previous versions of the system VC supports code comparison VC can provide full management of changes VC supports code integration d. Build and automate software deployments. e. Ensure there is a simple process ﬂow between creation and deployment. Processes must be optimized to eliminate bottlenecks to systems. Pre-Design Phase - Processes necessary before implementing the Design phase: a. Feasibility Study - An analyst must perform a detailed study focusing on the desired requirements and goals of the organization. This study will determine whether a practical software product can be created based Cost constraints Cost per value and objectives Analyzing the technical aspects of the project for its usability, maintain- ability, productivity, and system integration capability Internal Revenue Manual Cat. No.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "87d2a82689ec9cb6b074c23bf4d2a45e",
    "text": "P (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "ba5ec51d07a4ac0e951608704431d59a",
    "text": ")",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "585d0125b8a5fa5c29e6a4c88e7622ad",
    "text": "Ensure all software is written with clean code, and is well structured. Ensure all software is well tested (Peer testing, Unit test, Integration test, and System test). See IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "8733bf00a296e0ea04c138b04dc031c3",
    "text": "Testing Standards and Procedures IT Test Policy. All software must have Version Control (VC) applied: This is a central server (repository) versioning system that records changes to a ﬁle or of ﬁles over time so that you can recall speciﬁc versions later. The beneﬁts of using version control are listed below: VC has the ability of restoring previous versions of the system VC supports code comparison VC can provide full management of changes VC supports code integration Build and automate software deployments. Ensure there is a simple process ﬂow between creation and deployment.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "bfc9106d5f30ce2cf1c8e410ec196295",
    "text": "Ensure there is a simple process ﬂow between creation and deployment. Processes must be optimized to eliminate bottlenecks to systems.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "95eaeb68afe8e8204b367f35176ee7b3",
    "text": "Feasibility Study",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "ac8f6d1a52f03c9149f9812a2b1996b0",
    "text": "An analyst must perform a detailed study focusing on the desired requirements and goals of the organization. This study will determine whether a practical software product can be created based on: Cost constraints Cost per value and objectives Analyzing the technical aspects of the project for its usability, maintain",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "381b38ee009848864bac92500526bed5",
    "text": "ability, productivity, and system integration capability",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "7fbfee5344e73288994c76fde9d7d621",
    "text": "Analyzing the technical aspects of the project for its usability, maintain- productivity, and system integration capability",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 20
    }
  },
  {
    "element_id": "4d906fa27fe64bf0b8c3db55d0411401",
    "text": "Note: The output for this phase is the Feasibility Study report of recommendations, and is uploaded to the ITPAL SharePoint site as an artifact for: Require- ments Gathering, System Requirements Speciﬁcation (SRS), and Software Requirements Validation.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "e447ee82914a9e5cd857ee9de3fe4b65",
    "text": "a. Architectural Design",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "5de63ec81b531c2c451b18f163ab3d62",
    "text": "The architectural design is the highest abstract version of the system. This design identiﬁes the software as a system with many components interacting with each other. At this level the designer(s) focus on the proposed solution domain. b. High Design",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "e694f8bfda51f1c4cd8c2c5b86e90220",
    "text": "The high",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "4294f56dd6ce76518871adf67dcfb9ee",
    "text": "level design removes the ‘single entity",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "878913bb9368dfbec1c850f273737f62",
    "text": "multiple component’ concept of architectural design into less",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "df330f345140c03cdfb5c9fbfe7d6a67",
    "text": "abstracted view of sub",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "c2082e32f1cd27c21c761836ca0074ff",
    "text": "system and modules, and displays their interaction with each other. c. Detailed Design",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "a6c48918776e5eed2ea40aef24773f54",
    "text": "Detailed design pertains to the implementation part of what is seen as a system and its sub",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "7cd3619894313134906379a612c75632",
    "text": "system in the previous two designs. This is more detailed towards modules, and their implementations, and also describes logical structure of each module, and their interfaces to communicate with other modules.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "dbdeaf8cbd3707ba5206c93b96244cd7",
    "text": ") Software modeling addresses the entire software design including the inter- faces, interactions with other software, and all the software methods. Software models are ways of articulating a software design. For object-oriented software, an object modeling language such as Uniﬁed Modeling Language (UML) is used to develop and articulate the software design. In most cases, a modeling language is used to develop the design, not just to capture the design after it is complete. This allows the designer to try different designs, and decide which will be best for the ﬁnal solution. There are numerous approved modeling tools within the IRS, some tools for developers or Systems Architects are:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "1ad36bde33b69f8ef94376c2ee8ea13e",
    "text": "Unicom System Architect (Formally Rational System Architect) - System Architect is an enterprise architecture tool that enables you to build and automatically generate data-driven views of your organiza- tion’s enterprise architecture. This is also a meta-data discovery and management tool that enables you to extract, explore and analyze en- terprise application meta-data. Additionally, this tool is used to build architectures using different frameworks: The Open Group Architecture Framework (TOGAF), Department of Defense Architecture Framework (D",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "00f425a05d13a0093dc680703c259603",
    "text": "AF), and North Atlantic Treaty Organization (NATO) Architecture Framework (NAF). The Open Group Architecture Framework (TOGAF) Architecture De- velopment Method (ADM) - TOGAF is an architectural framework, and is a valuable tool for developing a wide range of different IT enterprise architectures that meets the needs of the customer. TOGAF enables you to design, evaluate, and build the right architecture aligning IT to the business initiatives. TOGAF is a high level approach to design. It is typically modeled at four levels: Business, Application, Data, and Tech- nology, and relies heavily on modularization, standardization, and already existing, proven technologies and products. Structure Charts - Currently structure charts are normally created for IRS mainframe systems, and are used to graphically model the hierarchy of processes within a system. Through the hierarchical format,",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "77876bdbf23945bdc74d7fab4bbaaae1",
    "text": "Unicom System Architect (Formally Rational System Architect) -",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "5ec0d93e908d16813093c13cc7f71e65",
    "text": "Structure Charts - Currently structure charts are normally created for IRS mainframe systems, and are used to graphically model the hierarchy of processes within a system. Through the hierarchical format,",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 21
    }
  },
  {
    "element_id": "3940fcab557ae53ed4306096b0c69bfd",
    "text": "the sequence of processes, and the movement of data and control pa- rameters can be mapped for interpretation.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 22
    }
  },
  {
    "element_id": "69276c0f8902f5aa9d94e1a69b273c0c",
    "text": "(1) Software Reﬁnement is a general approach of adding details to a software design. To ensure your formal design method properties are met during reﬁne-",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 22
    }
  },
  {
    "element_id": "38e92c447111b3fd20c526edf5027e25",
    "text": "design. To ensure your formal design method properties are met during reﬁne",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 22
    }
  },
  {
    "element_id": "f2b57986a80355e29210e64e48432625",
    "text": "ment:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 22
    }
  },
  {
    "element_id": "868f1d99a59846a56dadafa0b076f27c",
    "text": "You must use a notation that is natural to the problem space.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 22
    }
  },
  {
    "element_id": "1e046617e722ea8bbf190840ca69b528",
    "text": "Avoid using a programming language for description when possible.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 22
    }
  },
  {
    "element_id": "ee510eaaa770a54da56bdf3e727575be",
    "text": "The proposed steps must be easy to explain.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 22
    }
  },
  {
    "element_id": "23f4df9c1e8a493095df1a7fac116d55",
    "text": "The steps must make sense for the level of abstraction at which they are used. Software design principles provide the technique of how to handle the com",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 22
    }
  },
  {
    "element_id": "e68f24d3040ba92b1be71d9f740a0155",
    "text": "Software design principles provide the technique of how to handle the com- plexity of the design process effectively, see Software Design Principles ﬁgure",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 22
    }
  },
  {
    "element_id": "6418de976071f35562931047ea469dd4",
    "text": "Figure 2.5.12-5",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 22
    }
  },
  {
    "element_id": "cb8c5396339cfdbcc6dfc366917c84c7",
    "text": "Top-Down Approach : Characterized by moving from a basic description of the problem to detailed statements of what individual modules or routines do. Each reﬁnement entails several design decisions based on a set of design criteria. Each reﬁnement can proceed in two ways: top-down or bottom-up.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 22
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "8e6a6cca7aae1d1e781d3ee04849d6b0",
    "text": "Step",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "edfa91c11e1c8e3b8ae08890583a44e0",
    "text": "You must design the ﬁrst level of details ﬁrst. Step",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "9ddcb7318e3133054dba3ea0479bb389",
    "text": "Do not use any language speciﬁc details. Step",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "edaad7716a5e8747621588b756480e94",
    "text": "Create more details until you are at the lowest level. Step",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "2bbcbe101bce152ef15f6da5494b229a",
    "text": "Formalize each level. Step",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "61711f761d4488a57e769a98e989221b",
    "text": "Verify each level for correctness and clarity. Step",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "1df980c3c865ac54e9557d510511d23c",
    "text": "Move to the next lower level to create the next set of reﬁne- ments.Step",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "5f388c21f032df9d9c446c904671e8eb",
    "text": "Repeat the process starting with step",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "13a9a776dc3eaefef997362bb05d472b",
    "text": "Continue to reﬁne the solution at a lower level until it seems if it would be easier to code your program than to decompose the solution.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "1f251b6160065b61066d8d9daa15435f",
    "text": "(4) For a top-down illustration see the following ﬁgure:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "40f346ac329b8d29ecf3af941a30e8db",
    "text": "Figure 2.5.12-6 (5) Bottom-up Approach : A bottom-up approach begins with the lower details",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "d73e6ba632021749ebf4d7f83b50bfe7",
    "text": "Bottom-up Approach : A bottom-up approach begins with the lower details and moves up the hierarchy, and is suitable for an existing system. To view the bottom-up illustration, select the ﬁgure below:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 23
    }
  },
  {
    "element_id": "636914b679cb2af673b18b2d5459b772",
    "text": "Figure 2.5.12-7",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 24
    }
  },
  {
    "element_id": "14504ad172ea7ec75be845a4c7120f79",
    "text": "The main goal of heuristic evaluation is to identify any problems associated with the design of user interfaces. Heuristic evaluations are one of the most informal methods of usability inspection in the ﬁeld of human-computer interac- tions. Use the following rules of thumb to complete the evaluation of a design:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 24
    }
  },
  {
    "element_id": "0b026c751540a1fcff30f50d14a834e9",
    "text": "tions. Use the following rules of thumb to complete the evaluation of a design: a. Limit Module Size and Complexity: Keep your design modular, use the projected number of statements to determine whether a module is too small and must be combined with others, or a module is too large and must be broken down into sub functions. For example, when a module coded during programming, module size may require",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 24
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 24
    }
  },
  {
    "element_id": "7d8a13a8efb953d77ebbba3d3ebf7a89",
    "text": "statements for assembly language and",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 24
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 24
    }
  },
  {
    "element_id": "b1c4740749f9906351f3d23c5833d4ba",
    "text": "statements for a high-level language. Breaking your design up into semi-independent pieces has the following advantages:(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 24
    }
  },
  {
    "element_id": "2183a771d62331052ce75e4a85661c4a",
    "text": ")Keepsyour design manageable (Work on one part at a time and leave the others as black boxes) Helps with extensibility and maintainability Provides more checkpoints to measure progress Takes advantage of information hiding and encapsulation Allows for large programs to be written by several or different people b. Disadvantages of Modularity : Compilation and loading time could be longer. More linkage required, and run-time might be longer. More source lines must be written. More documentation is required. c. Limit the Span of Control (Fan-out) to",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 24
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 24
    }
  },
  {
    "element_id": "895e7edc2e96868ef1eb070ac787239a",
    "text": "immediate subordinate modules : The number of subordinates contributes to the complexity of a module’s processing. Combine subordinates if the span of control is high. If the span of control is low, compress the subordinate module into the immediate higher, super ordinate module. d. Maximize Fan-in : Fan-in is the use of a subordinate module by more than one super ordinate module. This avoids duplicate code.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 24
    }
  },
  {
    "element_id": "3095383250d97abe2a90181a423de9f2",
    "text": "Maximize Fan-in : Fan-in is the use of a subordinate module by more than one super ordinate module. This avoids duplicate code.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 24
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 25
    }
  },
  {
    "element_id": "e7b77919accd31605946af2d6812db2d",
    "text": "Verify Scope of Effect and Scope of Control : To ensure that modules affected by a decision are subordinate to the module which makes the decision. Modules, which are higher in the structure, must generally be control modules. These control modules comprise decision logic to control the invocation of their subordinates. Those at the lower level are function modules that perform actual transformations of data such as arithmetic calculations or report printing. Decompose a function into its sub",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 25
    }
  },
  {
    "element_id": "20883cd5dca38796cfba7ab73db6a061",
    "text": "functions, and then continue decomposition until atomic functions are reached. Any module with subordinates must be control oriented instead of performing the actual data transformations.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 25
    }
  },
  {
    "element_id": "a1f1f0652785d6e031ce3d267af172a0",
    "text": "Figure 2.5.12-8",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 25
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 25
    }
  },
  {
    "element_id": "3515cad59823521652ece192dd3f1b84",
    "text": ") Abstraction : Abstraction is creating detail at a higher level in the design hierarchy whether you are doing object oriented design, creating interfaces and abstract classes, or you’re doing a more traditional layered design, you want to use abstraction. Abstraction is a key element of managing the complexity of a large problem. By lifting away the details you can see the kernel of the real problem. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 25
    }
  },
  {
    "element_id": "5e5b25ab914974bd969fc9caa700ceee",
    "text": ") Encapsulation : Encapsulation refers to hiding/wrapping of data and functions into one unit. It is the key principle of software development, and the object- oriented design. Information hiding is the concept that you isolate information—both data and behavior—in your program so that you can isolate errors and changes; you also only allow access to the information via a well- deﬁned interface. For example: • If you are not using object-oriented design, use libraries for hiding behavior and use separate data structures (in C and C++) for hiding state. • If you are using object-oriented design, hide the details of a class, and only allow communication and modiﬁcation of data via a public interface.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 25
    }
  },
  {
    "element_id": "10c47635699514f16077c9b80a06b4c7",
    "text": "Abstraction : Abstraction is creating detail at a higher level in the design hierarchy whether you are doing object oriented design, creating interfaces and abstract classes, or you’re doing a more traditional layered design, you want to use abstraction. Abstraction is a key element of managing the complexity of a large problem. By lifting away the details you can see the kernel of the real problem.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 25
    }
  },
  {
    "element_id": "6c19b853b6902199453a5517f0931ea0",
    "text": "If you are not using object",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 25
    }
  },
  {
    "element_id": "267fb5963b6332ee0ed44cb5a5f5f0b1",
    "text": "oriented design, use libraries for hiding behavior and use separate data structures (in C and C++) for hiding state. If you are using object",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 25
    }
  },
  {
    "element_id": "0b797994a59fdb39a91301de37024382",
    "text": "oriented design, hide the details of a class, and only allow communication and modiﬁcation of data via a public interface.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 25
    }
  },
  {
    "element_id": "e46e65e7a86215e53c9a89221322d28e",
    "text": "you are using object-oriented design, hide the details of a class, and only allow communication and modiﬁcation of data via a public interface.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 25
    }
  },
  {
    "element_id": "83710ce18000830a317d2c9244331a75",
    "text": "A module is a well-deﬁned component of a software system, and a part of a system that provides a set of services to other modules.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 26
    }
  },
  {
    "element_id": "3dce08c8506f3cea20fd71943d2b6e8b",
    "text": "Encapsulation : A bundled group of services deﬁned by their data and behaviors together as a module. This group of services must be coherent, and clearly belong together e.g., like a function, a module must do just one thing. The module then presents an interface to the user, and that interface can access the services and data in the module. An objective of encapsulating services and data is high cohesion. This means modules whose elements are strongly related to each other. Loose/Low Coupling : A good design has low coupling. The various types of module coupling as seen in the following table IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 26
    }
  },
  {
    "element_id": "e7ac0786668e0ff0f02b62bd04f45ff6",
    "text": ":",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 26
    }
  },
  {
    "element_id": "d56d076b78bb5a700720591474a79da3",
    "text": "Types of Module Coupling and Ratings Simple Coupling Best Non-structured data is passed through parameter lists, and is best because it allows the receiving module to structure the data as needed, and decide what to do with the data. Stamp Coupling Good Two modules are stamp coupled if they communicate using composite data items such as: structure, objects, etc. When the module passes non-global data structure or an entire structure to another module, they are (stamp coupled). For example, passing an object in C++ language to a module. Structured Data Coupling Good Structured data is passed through a parameter list. This coupling is good because the sending module keep control of the data formats. Control Coupling Poor Data from module A is passed to module B , and the content of the data tells module B what to do. This is not a good form of coupling. A and B are too closely coupled because A is controlling how functions in module B will execute.",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 26
    }
  },
  {
    "element_id": "0c5d18362ddea05793195e2bf16c1e82",
    "text": "Types of Module Coupling and Ratings Global Data Coupling Worst Two modules share the same global data. Note: This violates a basic rule of en- capsulation by having the modules share data. This invites unwanted side-effects and ensures that at any given moment during the execution, module A nor module B will know what is in the globally shared data. Figure 2.5.12-9 c. Information Hiding : Information hiding is initiated only with Object",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "68065709098943eb752ec4c8cb3c8891",
    "text": "Figure 2.5.12-9",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "875c0097ae4f0c18bce89c9b98ec491d",
    "text": "Information Hiding : Information hiding is initiated only with Object Oriented Programming (OOP), and objects with their attributes and behaviors are hidden from other classes. This is not the same as encap",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "513efdcee6298ea87735a086be5097cf",
    "text": "sulation. The principles of information hiding are the following: All information related to an object is stored within the object Information is hidden from the outside world Information can only be changed by the object itself",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "777ab1f933da49c1d3d903a6b348f126",
    "text": ") During",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "88e6989fd976494627f787e6e613364a",
    "text": "four authors: Eric Gamma, Richard Helm, Ralph Johnson, and John Vlissides who are jointly known as the “Gang of Four”(GOF) published a book titled Design Patterns - Elements of Reusable Object-Oriented Software which started the concept of Design Pattern in Software Develop- ment. Design patterns provide an industry standard approach to solving recurring problems. standard terminology and signiﬁcance to each scenario. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "9df71ac08a8ec4a1131f3c30dcc877b1",
    "text": ") The GOF determined that design patterns are based on the following principles of object oriented design: • Program to an interface not an implementation • Accept object composition over inheritance (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "b27a5a4fdcd62aa66ab0f2d907e72104",
    "text": ") As referenced in the Gang of Four (GOF) Design Pattern reference book there are",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "ee3a780d008a4e37f3f9d8e21d249946",
    "text": "design patterns which are classiﬁed into three categories:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "6259eafc62aa40d8df1a69e0fa5bf3eb",
    "text": "During",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "d63e760592d858de56418d9bc3f00597",
    "text": "four authors: Eric Gamma, Richard Helm, Ralph Johnson, and John Vlissides who are jointly known as the “Gang of Four”(GOF) published a book titled Design Patterns - Elements of Reusable Object-Oriented Software which started the concept of Design Pattern in Software Develop- ment. Design patterns provide an industry standard approach to solving recurring problems. standard terminology and signiﬁcance to each scenario.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "2dd7d3777099151d8c9af8e7585033ea",
    "text": "As referenced in the Gang of Four (GOF) Design Pattern reference book there are 23 design patterns which are classiﬁed into three categories:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 27
    }
  },
  {
    "element_id": "279170f80ee8faa2bba0042017c59f42",
    "text": "a. Creational Patterns : Design patterns provide a way to create objects while hiding the creation logic, rather than instantiating objects directly using new operator. This provides more ﬂexibility when deciding which objects must be created for a use cases. The most common design patterns used for this category are: Abstract Factory Pattern - Allows the developer to separate out parts of the code that are changing frequently and encapsulating it in its own object (Connection objects, etc.) Builder Pattern - Allows the developer to build complex objects one step at a time, and produce different representations of an object using the same construction code Factory Pattern - Used when a superclass exist with multiple sub- classes and based on input, you need to return one of the sub-class. This pattern takes out the responsibility of the instantiation of a class Prototype Pattern - This pattern provides a mechanism to copy the original object to a new object, and then modify it according to the needs. Used when the object creation is costly, and requires a lot of time and resources and you have a similar object already existing Singleton Pattern - This pattern involves a single class which is re- sponsible to create an object while making sure that only single object gets created Strategy Pattern - This allow grouping related algorithms under an abstraction, which allows switching out one algorithm or policy for another without modifying the client from the client program to the factory class b. Structural Patterns : Pertains to class and object composition. The concept of inheritance is used to compose interfaces and deﬁne ways to compose objects to obtain new functionalities. The most common design patterns used for this category are: Adapter Pattern - This pattern is used so that two unrelated inter- faces can work together. The object that joins these unrelated interfaces is called an “Adapter” Bridge Pattern - This pattern enables the separation of implementation from the interface and is also known as “Handle” or “Body” Composite Pattern - This pattern is used when a part-whole hierarchy must be implemented, e.g., a diagram made of other pieces such as circle, square, triangle, etc. Decorator - This pattern allows a user to add new functionality to an existing object without altering its structure and act as a wrapper to existing class Facade Pattern - This pattern adds an interface to existing system to hide its complexities Flyweight Pattern - Used when the creation of many objects of a class is required. Since every object burns up memory space that can be crucial for low memory devices, such as mobile devices or embedded systems, the ﬂyweight design pattern can be applied to reduce the load on memory by sharing objects Proxy Pattern - Provides a placeholder for another object to control access to it, or control access to a functionality c. Behavioral Patterns : Concerned with algorithms and assigning responsi- bilities to objects. The most common design patterns used for this category are: Chain of Responsibility - Enables the developer to pass requests along a chain of handlers",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "f96747c3542394248a841f09315b3547",
    "text": "Systems Development Internal Revenue Manual Cat. No.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "87d2a82689ec9cb6b074c23bf4d2a45e",
    "text": "P (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "0be8135b2142f7831f91d1ab680013bf",
    "text": ") Any line marked with a is for Official Use Only",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "3e36384fbc7b28ff9469bc9fb20f7910",
    "text": "Adapter Pattern",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "8f64c61739d184077047ac5987fde6ec",
    "text": "This pattern is used so that two unrelated inter",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "59c6c441e74fb2f3e67dc65fb8d1d5d0",
    "text": "faces can work together. The object that joins these unrelated interfaces is called an “Adapter” Bridge Pattern",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "b965cceefcb3ad818214570fbe68760e",
    "text": "This pattern enables the separation of implementation from the interface and is also known as “Handle” or “Body” Composite Pattern",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "f4f3a09096eb12ce2d3bf1e4c89927f5",
    "text": "This pattern is used when a part",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "e3eaab4312581645843590b3314f049f",
    "text": "whole hierarchy must be implemented, e.g., a diagram made of other pieces such as circle, square, triangle, etc. Decorator",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "8c97d83ab88989d414d9f08cd9c6166a",
    "text": "This pattern allows a user to add new functionality to an existing object without altering its structure and act as a wrapper to existing class Facade Pattern",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "a71ed1e665c8d111b648739ccd5eccd3",
    "text": "This pattern adds an interface to existing system to hide its complexities Flyweight Pattern",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "52e327593dd4defb2d369a470f5294be",
    "text": "Used when the creation of many objects of a class is required. Since every object burns up memory space that can be",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 28
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 29
    }
  },
  {
    "element_id": "95b12629fd01db3ca8c1239c3be27c6c",
    "text": "Command Design Pattern - Turns requests into stand-alone objects containing all the information about the request Iterator Design Pattern - Allows iteration through elements in a col- lection without exposing the underlying representation Observer Design Pattern - Useful when you’re interested in the state of an object, and need to get notiﬁcations whenever there is any change. The object that watches the state of another object are called “Observer” and the object that is being watched is called “Subject.”(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 29
    }
  },
  {
    "element_id": "33fc763b2146ee76d54246331a248a3c",
    "text": ") Template Design Pattern - An abstract class exposes deﬁned ways/ templates to execute its methods. Its subclasses can override the method implementation as needed, but the invocation must be the same way as",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 29
    }
  },
  {
    "element_id": "92e3b1f8acc9b7e414ba80e3f8f0e26f",
    "text": "Iterator Design Pattern - Allows iteration through elements in a lection without exposing the underlying representation Observer Design Pattern - Useful when you’re interested in the of an object, and need to get notiﬁcations whenever there is any The object that watches the state of another object are called “Observer” and the object that is being watched is called “Subject.”(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 29
    }
  },
  {
    "element_id": "830007e730d50984a3d55d23b408e623",
    "text": ") Template Design Pattern - An abstract class exposes deﬁned templates to execute its methods. Its subclasses can override the implementation as needed, but the invocation must be the same way deﬁned by an abstract class (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 29
    }
  },
  {
    "element_id": "e96cbc05a42a73e08ad29e9b107ed942",
    "text": ") Design patterns are very useful if applied during the right situation, and for propriate reasons. Design patterns are like customizable templates that applied to programmers’ code regardless of programming language, and with common problems that arise within software design. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 29
    }
  },
  {
    "element_id": "7a3ba3528bb5e4e3153504fb53b5288f",
    "text": ") The best practices for developers using Design Patterns are as follows: a. Behavioral Patterns (Chain of Responsibility) - Use this pattern You need to process a notiﬁcation using a hierarchical chain of objects(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 29
    }
  },
  {
    "element_id": "4f6e4c9b8ffd4a5c1600b869be50a998",
    "text": ")Not every observer is created equally b. For Chain of Responsibility Pattern implementation see Chain of Responsibility Pattern Implementation A Create an Interface for the chain which has the method needed. B Speciﬁc classes in the chain must implement the Interface and the speciﬁc classes constructor must set up the Interface successor value (private value). C Top of chain (last notiﬁed), has no successor deﬁned D Each instance method deﬁned must be set up to deal with whatever event might be speciﬁc to that class in the chain. E If it can’t handle it, it passes it along to the successor.method() F Last method in chain must be able to handle event (in a generic way if nothing else) c. Behavioral Patterns (Iterator) - Use this pattern when: You want to access the elements of a collection without having to know any internal details of the collection You are dealing with a collection of objects You are mixing collection types and need to access them in a standard way d. For Iterator Pattern - For implementation see Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 29
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 29
    }
  },
  {
    "element_id": "b6aa12a6ad8ef15f687b80d9b5880f83",
    "text": "Design patterns are very useful if applied during the right situation, and for ap- propriate reasons. Design patterns are like customizable templates that can be applied to programmers’ code regardless of programming language, and help with common problems that arise within software design.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 29
    }
  },
  {
    "element_id": "fc7d4946b7ef72184afdfafa3cd51b89",
    "text": "A Create a class Iterator that implements Iterator • Give the class a local variable to store what is in the col- lection (array, vector, etc) • Add a local variable to keep track of where you are in the collection • Add the following methods: “next”, “hasNext”, and “remove” • The method “hasNext” returns a Boolean (true if not at the end of the collection) • The method “next” returns the succeeding item from the collection",
    "type": "UncategorizedText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 30
    }
  },
  {
    "element_id": "ee9dacb56d23e6b83b49db0d67a9173e",
    "text": "Figure 2.5.12-10",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 30
    }
  },
  {
    "element_id": "adeddb99f569487f1c2313826e10a38e",
    "text": "Observer Pattern Implementation",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 30
    }
  },
  {
    "element_id": "2b1bb1bf8d96f788040999877efe5dd9",
    "text": "A. Create a Subject (what is to be observed) Interface • registerObserver(Observer o) • removeObserver(Observer o) • notifyObserver(Observer o) B. Create an Observer Interface • receiveNotice() C. Class to be watched implements the Subject Interface D. Class to do watching implements Observer Interface F. registerObserver puts Observers into a Vector (removeObserver takes them out) G. When code needs to notify Observers, loop through the vector and call the Observers receiveNotice() method (passing in whatever is needed/expected)",
    "type": "UncategorizedText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 30
    }
  },
  {
    "element_id": "5732100a1a2a35bab9c5e65e17fa77fa",
    "text": "Figure 2.5.12-11",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 30
    }
  },
  {
    "element_id": "f771769c7fa3118560e8ab783bc9677a",
    "text": "Behavioral Patterns (Template)",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 30
    }
  },
  {
    "element_id": "d3c925676bbe67da5e00f610a51ca6ba",
    "text": "Use this pattern when: You have an algorithm that is made up of multiple steps, and you want to customize some of those steps If you have steps that are shared between various implementa",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 30
    }
  },
  {
    "element_id": "4d7064b79c08aaee202f60e519346237",
    "text": "tions of the algorithm",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 30
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "e6581373e4b10423e56c4b597b149b51",
    "text": "Note: Deﬁnes the skeleton of an algorithm leaving some steps to subclasses; however, if every step needs to be customized then this pattern is pointless",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "1850dd76d4245b3d777fc8459803f05c",
    "text": "h. For Template Pattern",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "1ff794d41c6f6432a92da9f919bf1097",
    "text": "For implementation do as follows: Deﬁne abstract class with ﬁnal method that calls all steps (functions) Deﬁne default behavior for steps in abstract class (public methods, not necessarily ﬁnal) Add conditions to steps if necessary Extend abstract class, override method for steps that are different i. Creational Patterns (Builder)",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "0197a9a0df94fb34d56cd8233653332f",
    "text": "Use this pattern when: You need to build complex sequence of steps",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "94414b44310ef90bfb09e3be3c1230bf",
    "text": "For Builder Pattern - For implementation see Figure 2.5.12-7",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "9620b007b6ee8e9a8ca63c3b35341da9",
    "text": "Builder Pattern Implementation",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "6841b4f2b7a2664c00217ff5baf69973",
    "text": "Figure 2.5.12-12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "40f6d83ad705630b201536280719b9dd",
    "text": "k. Creational Patterns (Factory)",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "c70cb9455235718518f21908451110e1",
    "text": "For implementation do as follows: Use this pattern when circumstances have gotten decentralized enough that many programmers who subclass your factory class are overriding it so much that they’re changing it substantially Note: Best when used to separate out parts of the code that are changing quently and encapsulating it in its own object (Connection objects, etc.)",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "eb510bbe75d6f0bd2e6dcd6a9419aabb",
    "text": "l. For Factory Pattern - For implementation do as follows: Build an abstract class (your base clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "cee7987b20873ac87755f9cb56a84a99",
    "text": "actory) Give your base “clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "810ed1bc45b7f740b327433d3434dd19",
    "text": "actory” any necessary abstract methods that must be implemented Create speciﬁc extensions of the “clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "40cbf135cbcebfe6b0cff14496325d38",
    "text": "actory” to meet the needs m. Creational Patterns (Flyweight) - Use this pattern when: Building an abstract class (your base clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "2baa2f66072b95b86a6297017337ae04",
    "text": "actory) The system has large, resource intensive objects, and you need to make the system less resource intensive Decompose large objects into generic, smaller objects that can be conﬁgured at runtime to appear as the large objects. This can save on system resources.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "2abe3d103811d5a4fe575fe3b4d50b05",
    "text": "Decompose large objects into generic, smaller objects that can be conﬁgured at runtime to appear as the large objects. This can save on system",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 31
    }
  },
  {
    "element_id": "572521c12314a067d2b6455971be712e",
    "text": "n. For Flyweight Pattern - For implementation do as follows: Create a class that contains only the data you might need (modeled after the larger class) Ensure you have created multiple constructors for the class (to set initial values based on the model of the data you need). Instead of setting everything, set only what is going to be used Create your class as a singleton to ensure that only one instance of Flyweight class is in existence. o. Creational Patterns (Singleton) - Use this pattern when: You need to restrict the number of objects created because you want the share the data in those objects You need to restrict resource usage (instead of creating numbers of large objects without limit) You need a sensitive object whose data shouldn’t be accessed by multiple instances such as a registry Note: To save on resources, you can select certain classes to be set up so that only one instance of your class exists. p. For Singleton Pattern - For implementation do as follows: Create your class ﬁle with a static variable of the type of the class Ensure the variable is initialized to a new instance of the class ﬁle Ensure you that have created a public static synchronized method returning an instance of your class (ge",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "6cef8c7eeffcb3ff964bac6f9971b687",
    "text": "nstance()) Ensure you that have created the ge",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "651b5e59efca713859ac380e0f4dbd97",
    "text": "nstance() method return the variable q. Creational Patterns (Strategy) - Use this pattern when: Volatile code exist that can be separated out of your application for easy maintenance You need to avoid confusing how to handle a task by having to split implementation code over several inherited classes You need to change the algorithm that you use for a task at runtime Note: Separate out volatile code into algorithms that contain a complete task. r. For Strategy Pattern - For implementation do as follows: Build an Interface to ensure all algorithms use the same methods All algorithms must implement the Interface The class must have a variable of the Interface; set using the speciﬁc algorithm needed for the instance of the class Note: Done with a “se",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "41665976fe162fddc5a64bea27182fff",
    "text": "nterface” method so that the algorithm changes runtime. s. Structural Patterns (Adapter) - Use this pattern when: You need to ﬁx the interfaces between two objects without having to change the objects directly (common in store-bought stuff) If what the object exposes isn’t what you need, add an adapter to build what you need When you have legacy code that can’t be changed Note: When you need to make incompatible objects talk to another, you use the exposed methods of one class to feed a secondary class, which then feeds the data into the second object’s exposed methods. t. For Adapter Pattern - For implementation do as follows:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "766b2fb68795b8abd844e200bd57515d",
    "text": "For Flyweight Pattern",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "a6bcd679001a5f447a5d3f0749f09ab2",
    "text": "For implementation do as follows: Create a class that contains only the data you might need (modeled after the larger class) Ensure you have created multiple constructors for the class (to set initial values based on the model of the data you need). Instead of setting everything, set only what is going to be used Create your class as a singleton to ensure that only one instance of Flyweight class is in existence. Creational Patterns (Singleton)",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "bedfb3dad2eecdecb5cfe27d8a86db69",
    "text": "Use this pattern when: You need to restrict the number of objects created because you want the share the data in those objects You need to restrict resource usage (instead of creating numbers of large objects without limit) You need a sensitive object whose data shouldn’t be accessed by multiple instances such as a registry",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "61009f2096c31700a341447613a6cb39",
    "text": "p. For Singleton Pattern - For implementation do as follows: Create your class ﬁle with a static variable of the type of the class itself Ensure the variable is initialized to a new instance of the class ﬁle Ensure you that have created a public static synchronized method returning an instance of your class (ge",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "6cef8c7eeffcb3ff964bac6f9971b687",
    "text": "nstance()) Ensure you that have created the ge",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "dd30168aaaf772c20c5a1834bdcc7161",
    "text": "nstance() method return the static variable q. Creational Patterns (Strategy) - Use this pattern when: Volatile code exist that can be separated out of your application for easy maintenance You need to avoid confusing how to handle a task by having to split implementation code over several inherited classes You need to change the algorithm that you use for a task at runtime",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "8f83675b7ee79b86d4823fe24a341522",
    "text": "Note: Separate out volatile code into algorithms that contain a complete task.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "b4696ae5d9beeb96e510c2070746a365",
    "text": "r. For Strategy Pattern - For implementation do as follows: Build an Interface to ensure all algorithms use the same methods All algorithms must implement the Interface The class must have a variable of the Interface; set using the speciﬁc algorithm needed for the instance of the class Note: Done with a “se",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "26c0089d2266d51ad3709a4b4ef00ed1",
    "text": "nterface” method so that the algorithm changes runtime. s. Structural Patterns (Adapter) - Use this pattern when: You need to ﬁx the interfaces between two objects without having to change the objects directly (common in store-bought stuff) If what the object exposes isn’t what you need, add an adapter to build what you need When you have legacy code that can’t be changed Note: When you need to make incompatible objects talk to another, you use the exposed methods of one class to feed a secondary class, which then feeds the data into the second object’s exposed methods. t. For Adapter Pattern - For implementation do as follows: Deﬁne an Interface to the second class Deﬁne a clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "5680d8d1cc79fe68dfcece6390e1e75a",
    "text": "dapter class using the interface",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "0956a88975b315828abd51565ce045eb",
    "text": "r. For Strategy Pattern",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "154f9d6e8b3b15e6d362d009a4e0c91d",
    "text": "For implementation do as follows: Build an Interface to ensure all algorithms use the same methods All algorithms must implement the Interface The class must have a variable of the Interface; set using the speciﬁc algorithm needed for the instance of the class",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "80dbcf54430cc904868c84533a01a014",
    "text": "When you need to make incompatible objects talk to another, you use the exposed methods of one class to feed a secondary class, which then feeds the data into the second object’s exposed methods.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "733d9db2d113ccaff56dfe7b29b6d751",
    "text": "For Adapter Pattern - For implementation do as follows: Deﬁne an Interface to the second class Deﬁne a clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "5680d8d1cc79fe68dfcece6390e1e75a",
    "text": "dapter class using the interface",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 32
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 33
    }
  },
  {
    "element_id": "054269dbaf3c9e301bf57406e8e282f7",
    "text": "w. Structural Patterns (Decorator)",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 33
    }
  },
  {
    "element_id": "1a2d5b343110d8ba042652648631ef45",
    "text": "Use this pattern when: You want to “decorate” the results of something in a class with something additional without having to modify the base class for all instances",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 33
    }
  },
  {
    "element_id": "327c116d9e63921998352900cd223ace",
    "text": "x. For Decorator Pattern - For implementation do as follows: Build an abstract class that extends your original class (clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 33
    }
  },
  {
    "element_id": "a82a12009b00e265231d093989155878",
    "text": "ecorator) that deﬁnes method(s) that must exist in all derived classes Derived class (extends clas",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 33
    }
  },
  {
    "element_id": "0232e76e0c4ae29094aa7f7a828b42ca",
    "text": "ecorator) must have local variable to hold base class (set with constructor) Decorator class calls method from base class, and extends it in some fashion (class.description() + decorator.description()) y. Structural Patterns (Facade) - Use this pattern when: A class interface is too hard to manipulate The code is poorly encapsulated You need the code to do “x, y, z” without a lot of intermediate steps You can’t rewrite the code to make it easier",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 33
    }
  },
  {
    "element_id": "33ff80d8a556c350643fdcc1ebe84cff",
    "text": "Note: Provides a wrapper to make original code more workable.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 33
    }
  },
  {
    "element_id": "c4ada895812ccd7e00ae4f3ed2af644d",
    "text": "For Facade Pattern",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "c2bf5f13027fff54047a74fe9c1cee13",
    "text": "For implementation do as follows: Façade class wraps the difficult class (like a Decorator) Make a simple method to do what is needed with the difficult class Provide methods to access the difficult classes simple methods",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "62a6da8735c18e2d66fe5de3dc544025",
    "text": "Object",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "b26dff3a3d181f987998366498102eb1",
    "text": "Oriented Analysis (OOA), Object",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "2865f4245838bc6f18d981617d80609a",
    "text": "Oriented Design (OOD), and Object",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "9b78e7405f77ff3676d8a6b024bb503d",
    "text": "Oriented Programming (OOP) are related, but different. (OOA) pertains to developing an object model of the application domain. OOA is a method of analysis that examines requirements from the perspective of the classes objects found in the vocabulary of the problem domain. The primary difference between an object",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "ed32d2e719402bcda5ab5bf75509254c",
    "text": "oriented analysis and other forms of analysis with the object",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "d17cf56ad4750559fb507182285bb0ba",
    "text": "oriented approach, requirements are focused on objects which integrate both data and functions. OOD involves implementation of the conceptual model produced during oriented analysis which are technology",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "98e28e9524ef0e5d25cddf9d6d7a74b7",
    "text": "independent. The conceptual model also mapped while implementing classes, constraints are identiﬁed and inter",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "ffd73a9ec6e1cf6e32c875271bfe9b63",
    "text": "faces are designed, resulting in a detailed description of how the system is be built on technologies.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "fafcad5aaf0721fad2e22508b8290fc1",
    "text": "public interface Point",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "ad33eed232816e43b032b53b9c675bd9",
    "text": "The primary differences between OOA and OOP are the following:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "567d3bf22946bc72363bdfaa2143b894",
    "text": "Object-Oriented Analysis and Object-Oriented Design Requirements",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 34
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 35
    }
  },
  {
    "element_id": "b2078fd1d3af982d00d1f95547ad75ce",
    "text": "Object-Oriented Analysis (OOA) Object-Oriented Design (OOD) Organize objects by creating object model diagram Implementation of methods e.g., internal data structures and algo- rithms Deﬁne the internals of the objects, or object attributes Implementation of control Deﬁne the behavior of the objects i.e., object actions Implementation of associations Describe how the objects interact Write or receive the problem statement. Use to generate an initial set of program features. Model data by creating Entity- Relationship diagrams Create a list of program features derived from the problem statement. This feature list may also be user stories. Deﬁne behaviors by creating ﬂow charts or structure charts Write up use cases : This will capture the goal of an action, the trigger event that starts a process, and describe each process step. Create prototypes or user- interface mock-ups Use the objects generated from your OOA and determine whether to use: inheritance, aggregation, composition, abstract classes, or interfaces in order to create an efficient model.",
    "type": "UncategorizedText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 35
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "fd9c4343b192475faf7a1a130d8a0d9f",
    "text": ") Case Diagrams (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "2fb7bf908f8b42ad0a39e6a02ae26481",
    "text": ") A use case is a Uniﬁed Modeling Language (UML) behavioral diagram used a graphic overview of the actors involved in a system, different functions needed by those actors, and how the different function interact. Use cases can be employed during several stages of software development, such as: planning system requirements, validating design, testing software, and creating an outline for user manuals. A use case diagram contains four components: a. System Boundary : Deﬁnes the system of interest in relationship to the project. b. Actors : These are the individuals involved with the project’s system, and are deﬁned according to their roles. c. Use Cases : A use case (or set of use cases) has the following character- istics:(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "4065f5c8a55ddfb5015964ff0bf94b2f",
    "text": ")Organizes all functional requirements. Models the goals of system/actor (user) interactions. Records paths (called scenarios) from trigger events to goals. Describes one main ﬂow of events (also called a Course of Action (COA)).(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "034415c623707dcbc6f832f9bcdfc59f",
    "text": ")Ismulti-level, so that one use case can use the functionality of another one. d. Relationship : This is the connection between the actors and the use cases.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "ad758926d8d62d4d4322e1e9f0b232ed",
    "text": ") Interface (UI) Principles (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "30f21769c794b3b3e81a7f83c10f2619",
    "text": ") The user interface is the front-end application view to which the user interacts in order to use the software product. The UI design must be: a. Attractive: Be purposeful with the page layout by considering the space between items on the web page, and structure the page based on impor- tance. b. Easy to use and understand. c. Strategic when using color and texture: Use color, light, and contrast base on guidance from IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "64bf3d77085e24ce15d8e865ab9e6af3",
    "text": "Organization, Finance, and Manage- ment, Publishing, Use of the Official IRS Seal, IRS Logo d. The design must be consistent on all interface screens.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "100895013f42561933835ed911234c1a",
    "text": ") Interface Design (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "348e61120b357a89293efff3add6e6f3",
    "text": ") User interface design is the process of making interfaces in software or com- puterized devices with the goal of making the user’s interface as simple and efficient as possible. The analysis and design process of a user interface is iterative, and can be represented by a spiral model. This UI consists of four framework activities: a. User, Task Environmental Analysis, and Modeling : Gather information of how the users will interact with system. Determine the user’s needs, challenges, and problems. Determine user’s experience, level of knowledge, and skills. b. Interface Design : Deﬁne the set of interface objects and actions i.e., control mechanisms that enable the user to perform their desired tasks. Design your interface in a way that allows the user to focus on what is most important. A good way to start your design is with simple wire- frames, mock-ups, and prototypes.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "e84e37f30aa24b786647d829dc2f8caf",
    "text": "Internal Revenue Manual Cat. No.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "87d2a82689ec9cb6b074c23bf4d2a45e",
    "text": "P (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "0be8135b2142f7831f91d1ab680013bf",
    "text": ") Any line marked with a is for Official Use Only",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "af168bcbf85caddc35cf36a54e0947b4",
    "text": "A use case is a Uniﬁed Modeling Language (UML) behavioral diagram used as a graphic overview of the actors involved in a system, different functions needed by those actors, and how the different function interact. Use cases can be employed during several stages of software development, such as: planning system requirements, validating design, testing software, and creating an outline for user manuals. A use case diagram contains four components:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "153ab87d2714c01ae7ccb28300c4c0ff",
    "text": "System Boundary : Deﬁnes the system of interest in relationship to the project. Actors : These are the individuals involved with the project’s system, and are deﬁned according to their roles. Use Cases : A use case (or set of use cases) has the following character- istics:(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "4065f5c8a55ddfb5015964ff0bf94b2f",
    "text": ")Organizes all functional requirements. Models the goals of system/actor (user) interactions. Records paths (called scenarios) from trigger events to goals. Describes one main ﬂow of events (also called a Course of Action (COA)).(cid:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "bf4e6a7110b0caf53654a44e9bcf5acb",
    "text": ")Ismulti-level, so that one use case can use the functionality of another one. Relationship : This is the connection between the actors and the use cases.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "757fc30c7d69cadcaccdaa8e11ad03a6",
    "text": "The user interface is the front-end application view to which the user interacts in order to use the software product. The UI design must be:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "32b971df1cad69d12be294132a776f8f",
    "text": "The user interface is the front-end application view to which the user in order to use the software product. The UI design must be: a. Attractive: Be purposeful with the page layout by considering the between items on the web page, and structure the page based on tance. b. Easy to use and understand. c. Strategic when using color and texture: Use color, light, and contrast base on guidance from IRM",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "6ba53400925e21a2db6b70779dd8718e",
    "text": "Organization, Finance, and ment, Publishing, Use of the Official IRS Seal, IRS Logo d. The design must be consistent on all interface screens. User interface design is the process of making interfaces in software or puterized devices with the goal of making the user’s interface as simple efficient as possible. The analysis and design process of a user interface iterative, and can be represented by a spiral model. This UI consists of framework activities: a. User, Task Environmental Analysis, and Modeling : Gather information of how the users will interact with system. Determine the user’s needs, challenges, and problems. Determine user’s experience, level of knowledge, and skills. b. Interface Design : Deﬁne the set of interface objects and actions i.e., control that enable the user to perform their desired tasks. Design your interface in a way that allows the user to focus on most important. A good way to start your design is with simple wire- frames, mock-ups, and prototypes.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "5b015d51a4a91ef27976dcc8de8febe7",
    "text": "a. Attractive: Be purposeful with the page layout by considering the space between items on the web page, and structure the page based on impor-",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "6b17203683bbe7892858fb2d211100c6",
    "text": "a. User, Task Environmental Analysis, and Modeling : Gather information of how the users will interact with system. Determine the user’s needs, challenges, and problems. Determine user’s experience, level of knowledge, and skills. b. Interface Design : Deﬁne the set of interface objects and actions i.e., control mechanisms that enable the user to perform their desired tasks. Design your interface in a way that allows the user to focus on what is most important. A good way to start your design is with simple wire",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "bf0f8ca6fb6a3148f797464e0dc6f353",
    "text": "frames, mock",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "8018ef0a6a4a1e31f55b85e096d6ea5a",
    "text": "ups, and prototypes.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 36
    }
  },
  {
    "element_id": "eb14f674c95b618f210173a5d2b6b1d2",
    "text": "Design ways for the users to undo actions i.e., a user inputting wrong information will be allowed to select an “Undo” button, and enter the correct information. Provide Feedback to Users : Your interface must display visual cues or simple messaging that show users whether their actions are valid, and have led to the expected results. c. Interface Validation : The interface must implement every user task correctly, and accommo- date all tasks variations based on project requirements. Verify user acceptance and validation of the interface’s design and usability for their work environment. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "173ebbc090cc6d9abc41a86df31d8a32",
    "text": ") Wireframes : A wireframe is a skeletal framework of a product or solution. Wireframes are low-ﬁdelity visualizations that can be created using non- technical mediums i.e., whiteboarding or using design or prototyping software. a. Wireframes are created before design work begins, and serve as a blueprint that deﬁnes each web page’s structure, content and functionality so the focus is on layout without the distraction of color and visual elements. The following must be considered when creating wireframes: Gathering Requirements: Add all requirements that answer concerns by the customer and project team. Include Important Elements: Wireframes must include all the important elements of a web page or user interface e.g., navigation, company logo, search function, user input, and user log-in areas. Must be practical and usable, but also organize your ideas in an orderly manner. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "b85c0b123984792d2ef49d76017b9269",
    "text": ") IRS Approved Software : One approved tool for creating your wireframe diagrams is Microsoft Visio, but when a license is not available Powe",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "ad450063e83f3b3b2a68d15c46678efe",
    "text": "oint is an alternative. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "c9d03f3fbd4b280dd2e9445b1975758e",
    "text": ") Mock-up : A mock-up is a realistic visual detail of the products appearance, and must display the basics of its functionality. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "089b29e26ea79532d57f3e56884f1c6a",
    "text": ") For more IRS guidance on design wireframes and mock-ups, see Business Planning and Risk Management (BPRM), Requirement Engineering Program Office (REPO) guidance link http://it.web.irs.gov/brrm/assets/REPO_Viz_",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "fbd4c870dd58e52f978d50578ec7e91e",
    "text": "Design ways for the users to undo actions i.e., a user inputting wrong information will be allowed to select an “Undo” button, and enter the correct information. Provide Feedback to Users : Your interface must display visual cues or simple messaging that show users whether their actions are valid, and have led to the expected results. c. Interface Validation : The interface must implement every user task correctly, and accommo",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "f84ed8dd6c00714e43731a75c75065fa",
    "text": "date all tasks variations based on project requirements. Verify user acceptance and validation of the interface’s design and usability for their work environment.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "8e99e3342fcc07e993131116982799c9",
    "text": "Wireframes are created before design work begins, and serve as a blueprint that deﬁnes each web page’s structure, content and functionality so the focus is on layout without the distraction of color and visual elements. The following must be considered when creating wireframes: Gathering Requirements: Add all requirements that answer concerns by the customer and project team. Include Important Elements: Wireframes must include all the important elements of a web page or user interface e.g., navigation, company logo, search function, user input, and user log",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "29f3bbf618f70097a7e349694ef1e464",
    "text": "in areas. Must be practical and usable, but also organize your ideas in an orderly manner.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "b85c0b123984792d2ef49d76017b9269",
    "text": ") IRS Approved Software : One approved tool for creating your wireframe diagrams is Microsoft Visio, but when a license is not available Powe",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "cde137fba98f94bf03c77fe0a4197a29",
    "text": "oint is an alternative.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "c9d03f3fbd4b280dd2e9445b1975758e",
    "text": ") Mock-up : A mock-up is a realistic visual detail of the products appearance, and must display the basics of its functionality. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "11346fb730e1bae7fe26ce190ce3a03b",
    "text": ") For more IRS guidance on design wireframes and mock-ups, see Business Planning and Risk Management (BPRM), Requirement Engineering Program Office (REPO) guidance link http://it.web.irs.gov/brrm/assets/REPO_Viz_ Consumption_Guidance_v",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "d2e2adf7177b7a8afddbc12d1634cf23",
    "text": "_",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "318a0a494d8487e946a07b2651781b21",
    "text": "pdf#search=wireframe . (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "687945c852812e660860cb140ccaa04c",
    "text": ") A prototype is a representation of a ﬁnished product, and is initiated at the of any project to gather requirements. Prototypes are a way for designers developers to test the ﬂow, interaction, content, feasibility, and usability before building and designing a fully-functioning product. Prototypes are not meant be the ﬁnal product; some features won’t work, it will not be pixel-perfect, the design and copy won’t be ﬁnalized. The prototyping model has the following Software Development Life Cycle (SDLC) phases:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "f426ce4d55003e5aab5f642171d74c16",
    "text": "Mock-up : A mock-up is a realistic visual detail of the products appearance, and must display the basics of its functionality.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 37
    }
  },
  {
    "element_id": "60fee2bce3772f80684d2b3a6d4a10b6",
    "text": "Prototyping Model Software Development Life Cycle (SDLC) Phases",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 38
    }
  },
  {
    "element_id": "6ee72853f060d59893cb3dfaba4561c2",
    "text": "Prototyping Model SDLC Phases Step 1. Requirements gathering and analysis a. During this process, the users of the system are interviewed to determine what is their expectations. Step 2. Quick design a. A simple design of the system is created that provides a brief idea of what can be implemented to the user. This preliminary design helps in develop- ing the prototype. Step 3. Build a Prototype a. An actual prototype is designed based on the infor- mation obtained from the quick design. This is a small working model of the required system. Step 4. Initial user evaluation a. Present the proposed system to the customer for an initial evaluation. This will help determine the strength and weakness of the working model. b. All comments/suggestions are collected from the customer, and provided to the developer. Step 5. Reﬁne the prototype a. If the customer is not satisﬁed with the current prototype, you need to reﬁne the prototype according to their feedback and suggestions. This phase will not be over until all requirements identi- ﬁed by the user and/or customer are met. b. After the user/customer is satisﬁed with the developed prototype, a ﬁnal system is developed based on the approved ﬁnal prototype. Note: Collaboration with Enterprise Operations (EOps) is also necessary. Step 6. Implement Product and Maintain a. Complete all Enterprise Life Cycle documentation in according with ELC Guidance IRM 2.16.1. b. After the ﬁnal system is developed based on the ﬁnal prototype, you must collaborate with users to thoroughly test and deploy to production. Note: Collaboration with Enterprise Operations (EOps) is also necessary.",
    "type": "UncategorizedText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 38
    }
  },
  {
    "element_id": "7cfebbb89da66c7996108dd80e9340d3",
    "text": "a. Use prototyping when the requirements are unclear. b. Perform scheduled and controlled prototyping. c. Schedule regular meetings to keep the project on time and avoid costly delays. d. Inform users, customers, and the designers promptly of any prototyping problems or concerns. e. Implement all important features early so that if you run out of time, you still have a worthwhile system. f. Do not allow your team to move to the next step until the initial prototype is approved during project initiation stage. g. Select the appropriate step size for each version.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 38
    }
  },
  {
    "element_id": "b398d3d2f4d45c07ee284efc09d07600",
    "text": "The use of prototypes can be used during any of the ELC milestones, see table IRM 2.5.12.4.2.2:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 39
    }
  },
  {
    "element_id": "d0c43fdfd50add9887424948221d0c1f",
    "text": "ELC Milestones and Prototyping Beneﬁts",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 39
    }
  },
  {
    "element_id": "c5ead4ef13bd42dbc87ce43b82915057",
    "text": "ELC Milestones and Prototyping Beneﬁts ELC Milestones ELC Prototyping Beneﬁts 1. MS 0 - Vision & Strategy • Provides an increased understand- ing for portfolio prioritization and decision making 2. MS 1 - Project Initia- tion • Known to accelerate project start-up and enforcement of standards through the use of common reusable libraries 3. MS 2 - Domain Archi- tecture MS 3 - Preliminary Design MS 4a - Detailed Design • Provides a better understanding of scope, system boundaries, and requirements among all stakehold- ers • Enhances the ability to review, iterate, and validate requirements through visual models rather than traditional statements • Accelerates knowledge transfer to dependent teams • Enhances test case creation 4. MS 4b - System De- velopment • Improves clarity for requirements resulting in less rework during de- velopment • Accelerates training and use case development because of visualiza- tion • Mitigates risks through early user engagement and user-centric design",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 39
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 39
    }
  },
  {
    "element_id": "4980c42e85c334426c58ee2a98e0c31d",
    "text": ") A structure chart is a top-down modular design tool that represents two main graphical elements: modules shaped as rectangles, and the arrows that denote relationships between modules and data movement. The structure diagram is method of designing a solution to solve a software problem. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 39
    }
  },
  {
    "element_id": "0eabc24fd8c6e5fcf4762f1319bb96e7",
    "text": ") Common Types: a. Work Breakdown - This structure chart is used during project manage- ment for displaying milestones. b. Organizational - A diagram that displays the structure of an organization’s reporting hierarchy within a business, government, or organization. The types of structure are: Hierarchical (most popular), Matrix, and Horizontal/ Flat.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 39
    }
  },
  {
    "element_id": "d0a81ceb4d1f3c544a4c6e8484b2b5ab",
    "text": "A structure chart is a top-down modular design tool that represents two main graphical elements: modules shaped as rectangles, and the arrows that denote relationships between modules and data movement. The structure diagram is a method of designing a solution to solve a software problem.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 39
    }
  },
  {
    "element_id": "12119296334e73f2795eb09a976033bf",
    "text": "Figure 2.5.12-16 (4) Each structure chart forms a graphic model of the program’s design shown through a hierarchy of modules. Use the structured design technique after structured analysis. One aspect of structured analysis is “packaging”, or subdi- viding of the data ﬂow diagrams into subsystems consisting of related groups of processes. In structure design, a separate structure chart will then model each run/process. Although structured analysis provides a bridge to structured design, it is not a prerequisite to the design. Regardless of the analysis technique used, a system still must be subdivided into a group of runs or processes, at which point structured design shall begin. (5) In a project where structured analysis was not required or employed, the prin- ciples applied in partitioning the data ﬂow diagrams must still be applied to arrive at a high-level system schematic that then can be used for a design implementation. 2.5.12.5.1(12-16-2021) Structure Chart Best Practices (1) Each structure chart must depict the following: • Modules must be graphically represented by boxes, joined together in a tree-like structure by module connectors, graphically represented by lines to show superior and subordinate modules. • Interface parameters or couples must be graphically represented by short arrows with a circular tail, used to show movement of data items from one module to another.",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 40
    }
  },
  {
    "element_id": "587e5cd801447de96dbf8daa806f2e07",
    "text": "Hierarchical format of a structure chart",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 40
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 40
    }
  },
  {
    "element_id": "13b52dc98500c31926a8489b842faccc",
    "text": ") Each structure chart forms a graphic model of the program’s design shown through a hierarchy of modules. Use the structured design technique after structured analysis. One aspect of structured analysis is “packaging”, or viding of the data ﬂow diagrams into subsystems consisting of related groups of processes. In structure design, a separate structure chart will then model each run/process. Although structured analysis provides a bridge to structured design, it is not a prerequisite to the design. Regardless of the analysis technique used, a system still must be subdivided into a group of runs or processes, at which point structured design shall begin. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 40
    }
  },
  {
    "element_id": "fc3b887eb809777b63baf85240324f8a",
    "text": ") In a project where structured analysis was not required or employed, the ciples applied in partitioning the data ﬂow diagrams must still be applied to arrive at a high-level system schematic that then can be used for a design implementation. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 40
    }
  },
  {
    "element_id": "226ed7137ca0019796a789629a780979",
    "text": ") Each structure chart must depict the following: • Modules must be graphically represented by boxes, joined together tree-like structure by module connectors, graphically represented by lines to show superior and subordinate modules. • Interface parameters or couples must be graphically represented by short arrows with a circular tail, used to show movement of data items from one module to another. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 40
    }
  },
  {
    "element_id": "3ed84ada95efb4c5170dad419c097983",
    "text": ") The ﬁgure below illustrates the basic format of a structure chart. Module names and numbers, and interface parameter names have been omitted for the sake of simplicity, although they normally a part of any structure chart.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 40
    }
  },
  {
    "element_id": "0b7f9c8ac67f4ae6ba5dfa31d4883d23",
    "text": "Modules must be graphically represented by boxes, joined together in a tree",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 40
    }
  },
  {
    "element_id": "2bd18433e82dfb52ed74ddc7b91e9b46",
    "text": "like structure by module connectors, graphically represented by lines to show superior and subordinate modules. Interface parameters or couples must be graphically represented by short arrows with a circular tail, used to show movement of data items from one module to another.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 40
    }
  },
  {
    "element_id": "e3b0c44298fc1c149afbf4c8996fb924",
    "text": "",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "1f5be66894e5ef6a6919e1f6499a7c1e",
    "text": "Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "652cf3d99f4aaaac0610ef9dd3cf104b",
    "text": "Basic Format of a Structure Chart (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "89d0002c496055ec315134c8165861a8",
    "text": ") Examine the partitioned data ﬂow diagrams and apply transform and/or trans- action analysis to accomplish the initial development of a structure chart. Use these strategies to examine and analyze the data ﬂow as graphically presented in data ﬂow diagrams; these strategies require judgment. Apply the basic concepts of transform and/or transaction analysis to any design regardless of whether structured analysis preceded structured design. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "235952b59deb7a021dd6b305c9f37803",
    "text": ") Other criteria exist to evaluate and improve the quality of a design. Properly apply the concepts of cohesion, coupling, decision splitting and other heuristics to produce a well-partitioned and easily maintained system. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "983c3847679b3619e32f3a4ebc60d5d0",
    "text": ") Transform analysis is the process of taking a Data Flow Diagram (DFD), and converting it to a structure chart. The idea behind transform analysis is trans- forming an input data ﬂow into an output data ﬂow, and the central transform the central process that transforms the data. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "d343ff431965241cc5c25bb84c7b4b11",
    "text": ") Transaction analysis is the process of identifying a set of transactions (usually via DFD fragments), and developing a structure chart with a calling structure call a module for each transaction. Best (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "3a81b5bd4010e5f09eba82d9f49e3f27",
    "text": ") Use Transform Analysis to analyze the data ﬂow diagram, identify the primary processing functions, high-level inputs, and high-level outputs, and provide a “ﬁrst draft” of a structure chart, resulting in a design that bears a simple straightforward relationship to the data ﬂow. The ﬁnal design will be a reﬁne- ment of this initial structure, which will reﬂect alterations based on the concepts of cohesion and coupling. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "4a44680c0eeba9903e22d89451722c45",
    "text": ") Apply the following steps to develop structures which are fully, or almost fully factored: a. Identify highest-level data and the transform center; b. Apply ﬁrst-level factoring; and c. Apply full-system factoring. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "6726c0a6ddbc7e77d189e9318f57a047",
    "text": ") Internal Revenue Manual",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "8535ef8b4ffcc1fc6ab9999c3807b1e7",
    "text": "a #",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "e73b4026e125739ba4e4c25191e2bbf2",
    "text": "Figure 2.5.12-17 Basic Format of a Structure Chart",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 41
    }
  },
  {
    "element_id": "31cf6de84587aa667f2c69de3a118a97",
    "text": "(3) To identify the highest-level data and the transform center, study each partition of the data ﬂow diagram to determine what point the input data no longer rep- resents input to the system and at what point data can be perceived as becoming output. Consider the following: • Afferent data is physical input data transformed to logical input as it passes through the data ﬂow diagram. As this incoming data moves through the data ﬂow diagram, it becomes more abstract and highly processed until it reaches a point at which it can no longer be consid- ered input. This is the point of highest-level afferent data. • Efferent data is logical output transformed to physical output as it passes through the data ﬂow diagram. If this data is traced back through the data ﬂow diagram, a point is reached at which the output data stream can no longer be recognized as output. This is the point of highest-level efferent data, the point at which the data elements have had the least amount of processing to convert them to output data. • The data transformation(s) between the afferent and efferent data elements represents the transform center, where data not recognizable as either input or output is processed. • A data ﬂow diagram may contain multiple afferent and efferent streams and/or transform centers. (4) Figure 2.5.12-2 illustrates a simpliﬁed example of a run/process to which transform analysis has been applied. page 32 2.5 Systems Development",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 42
    }
  },
  {
    "element_id": "33ce52f6829ff02726d2a484db5b4a04",
    "text": "To identify the highest-level data and the transform center, study each partition of the data ﬂow diagram to determine what point the input data no longer rep- resents input to the system and at what point data can be perceived as becoming output. Consider the following:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 42
    }
  },
  {
    "element_id": "b9876e05f639258320bf5d89131f3674",
    "text": "becoming output. Consider the following: • Afferent data is physical input data transformed to logical input as it passes through the data ﬂow diagram. As this incoming data moves through the data ﬂow diagram, it becomes more abstract and highly processed until it reaches a point at which it can no longer be consid- ered input. This is the point of highest-level afferent data. • Efferent data is logical output transformed to physical output as it passes through the data ﬂow diagram. If this data is traced back through the data ﬂow diagram, a point is reached at which the output data stream can no longer be recognized as output. This is the point of highest-level efferent data, the point at which the data elements have had the least amount of processing to convert them to output data. • The data transformation(s) between the afferent and efferent data elements represents the transform center, where data not recognizable as either input or output is processed. • A data ﬂow diagram may contain multiple afferent and efferent streams and/or transform centers. Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 42
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 42
    }
  },
  {
    "element_id": "bb9016b80462bb5326ce3c3fe00e0a37",
    "text": "illustrates a simpliﬁed example of a run/process to which",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 42
    }
  },
  {
    "element_id": "e3b0c44298fc1c149afbf4c8996fb924",
    "text": "",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 42
    }
  },
  {
    "element_id": "760dc29d84077c4b9ef6f02c52c60afd",
    "text": "Figure 2.5.12-18 Data Flow Diagram that resulted from Transform Analysis",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 42
    }
  },
  {
    "element_id": "5879a8a6d982ce469b6c63684899235b",
    "text": "(5) To apply ﬁrst-level factoring, identify subfunctions subordinate to a module. At the ﬁrst-level, this results in modules that represent afferent and efferent data streams and the central data transformation point. The following ﬁgure illus- trates ﬁrst-level factoring.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 42
    }
  },
  {
    "element_id": "facf05665709c6cd7650892d68fb3d3e",
    "text": "Figure 2.5.12-19 (6) To apply full-system factoring, break down each branch of the system into sub- functions to the lowest process level and physical input/output module to",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 43
    }
  },
  {
    "element_id": "db023e4fa8d4a087ba8c50a81ac311fa",
    "text": "To apply full-system factoring, break down each branch of the system into sub- functions to the lowest process level and physical input/output module to accomplish full-system factoring. The following ﬁgure depicts a structure chart that models an example of a transform-centered system.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 43
    }
  },
  {
    "element_id": "e3b0c44298fc1c149afbf4c8996fb924",
    "text": "",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "1f5be66894e5ef6a6919e1f6499a7c1e",
    "text": "Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "8b392ae7249a8393e5d5c2e02b8b9f3d",
    "text": "Full System Factoring (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "3972da08148afc62c17729c64aaada37",
    "text": ") Use transaction analysis to analyze the data ﬂow diagrams and develop a module structure that is based on the processing of transactions. A transaction is any element of data, control, signal, event, or change of state, which causes an action. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "b6e2ab014ec9777536ed240f568fd169",
    "text": ") To apply transaction analysis, perform the following steps:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "c3366ef0a899ce88aa4eade85a73c082",
    "text": "Identify the sources of transaction.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "9096bf768fb08b4f9ddc4b92eb4fdcd2",
    "text": "Identify transactions and the processing that takes place for each trans- action.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "8fbb490e9de10f61686b1ede51ca32d1",
    "text": "Specify a module to process each transaction.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "82622375af1733d8f0d2d232462a8fe3",
    "text": "Factor each transaction module by developing subordinate action modules.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "943ab0578dda90067c78e41b2e681ace",
    "text": "Factor each action module by developing subordinate detail modules. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "2675ffded90f13772fed927384e114f7",
    "text": ") The following ﬁgure shows a data ﬂow diagram for a transaction-centered system.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "fda2171065612eb77d51cef23f193dcb",
    "text": "Figure 2.5.12-20 Full System Factoring",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 44
    }
  },
  {
    "element_id": "e3b0c44298fc1c149afbf4c8996fb924",
    "text": "",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 45
    }
  },
  {
    "element_id": "f177da4e28cc833afc9eeafc723c1563",
    "text": "Figure 2.5.12-21 Data Flow Diagram for a Transaction-Oriented System",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 45
    }
  },
  {
    "element_id": "03c7daa779b434cfd77fd31df6782bd2",
    "text": "(4) Develop the structure chart below for a transaction-centered run/process. See Figure 2.5.12-15. Module 1 is the “Transaction Processor”. Modules 1.2, 1.3, and 1.4 are the “Action Modules”. Module 1.2.1, 1.2.2, and 1.3.2 are the “Detail Modules”.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 45
    }
  },
  {
    "element_id": "ab631e8acb93240064787820070d6162",
    "text": "Figure 2.5.12-22 Structure Chart",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 46
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 46
    }
  },
  {
    "element_id": "c621fe37b3bcbd16eb5a2a9f2b9e9990",
    "text": ") Throughout the development of the structure chart, determine what information a module needs in order to function. Once a preliminary design is developed, specify the information that is external to that module on the structure chart, in the form of parameters. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 46
    }
  },
  {
    "element_id": "a2a1fc0c4923a1a6aa2367925243f71e",
    "text": ") Use parameters to pass information from one module to another. Parameters can be data or process control information. Parameter passing allows modules to be independent of each other. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 46
    }
  },
  {
    "element_id": "65e5cc1f905101c199141e61a8cd1fbb",
    "text": ") Although information can also be accessed from a common environment, this increases the complexity of the design and binds modules together (increases coupling). Limit your use of this approach. Ensure that the design only reﬂects the data, which each module needs in order to do its job (e.g., if the program under design evolves into a single unit that can be compiled, do not treat the entire data storage area as common).",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 46
    }
  },
  {
    "element_id": "026914b42ea1d9e24bc261afe01bde0e",
    "text": "Although information can also be accessed from a common environment, this increases the complexity of the design and binds modules together (increases coupling). Limit your use of this approach. Ensure that the design only reﬂects the data, which each module needs in order to do its job (e.g., if the program under design evolves into a single unit that can be compiled, do not treat the entire data storage area as common).",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 46
    }
  },
  {
    "element_id": "b78044d48382c45c3b0e4b10198e4722",
    "text": "Chart (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "627686172cfe7e53316436952e2ade16",
    "text": ") Once a structure chart is developed using transform and/or transaction analysis, evaluate it and identify those areas that can be reﬁned. By using concepts of coupling and cohesion, and applying the rules of thumb described below, the designer can identify and improve the structure of the system. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "a8cce395d6ffe79f4db355996728d64b",
    "text": ") The revised structure chart must result in an improved design that does not deviate drastically from the original design. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "5e3c065d858e4c3080c3fe370b2d3ae3",
    "text": ") Use the following three methods to identify the strengths and weaknesses design: • Cohesion • Coupling • Heuristics (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "be54ba710dbafd824df9589e16750472",
    "text": ") Cohesion measures the strength of associations between the processing elements within a module. A processing element can be a statement, segment, or subfunction. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "c83c0418654eaee9c0d749aa4b5cc700",
    "text": ") Maximize the relationships among the elements to obtain an optimal modular design that will increase the reliability, extensibility, and maintainability of the program. Strong and independent modules can often be used in other programs. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "428714565b0996bab5205455b671294e",
    "text": ") A highly cohesive module is a collection of statements and data items that must be treated as a whole because they are functionally related, that is, the module performs a single function. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "e95f19dc3d27ef2b90be458af1f31202",
    "text": ") Acceptable but weaker cohesion exists in a module when several related are grouped together because they are strongly bound by use of the same closely related data items. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "5a0852200e4826b3a523e63ddd76632a",
    "text": ") Unacceptable cohesion exists in a module when it performs unrelated tasks, bound together by weak relationships. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "189634cc8aa2ab1367165b17f77d3fb0",
    "text": ") Name the module or describe its function in a single sentence to test for cohesion. If this can accurately be done using only one transitive verb and speciﬁc non-plural object, then the module is of acceptable cohesion. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "18afa127d7ac5535336ad1211d464289",
    "text": ") Apply cohesion to individual modules as well as the whole design structure. When applying this name test, ensure that the upper level module’s name reﬂects the function of the modules subordinate to it. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "ec1579d740951652e3487bc25cf47af8",
    "text": ") Coupling measures the interdependency between modules. A design that minimal coupling between its modules is easy to maintain. The higher the degree of coupling, the more a programmer will need to consider other modules when coding, debugging, or modifying one module, and the more likely it will be that a change to the inside of one module will affect the proper functioning of another module. Low coupling between modules signiﬁes a partitioned system. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "8a5d025e100d10b1bb25f1f217bb8014",
    "text": ") There are three major factors that can increase or decrease coupling. These factors are: • Type of connection between modules • Complexity of interface • Type of information transmitted between modules Techniques and Deliverables",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "3660315a9af3df255d8f19ab077e4797",
    "text": "page",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "87d2a82689ec9cb6b074c23bf4d2a45e",
    "text": "P (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "6726c0a6ddbc7e77d189e9318f57a047",
    "text": ") Internal Revenue Manual",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "564655922549bd9378e3f6a0a33827ef",
    "text": "with a # Use Only",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "4ee7ecf05dbea924c010ef07e5488622",
    "text": "Once a structure chart is developed using transform and/or transaction analysis, evaluate it and identify those areas that can be reﬁned. By using the concepts of coupling and cohesion, and applying the rules of thumb described below, the designer can identify and improve the structure of the system.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 47
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 48
    }
  },
  {
    "element_id": "26fae1b7955ca721ce88dc013794af9f",
    "text": ") The type of connection between modules involves: • A minimally connected system includes modules with single interfaces supported by parameter passing (one entry/one exit, with return always to the calling module at the next executable instruction). Minimal con- nectivity is the acceptable standard. • A system that contains modules with multiple entry points, alternate returns, unconditional transfer of control to a normal entry point, or any combination of the three is undesirable and unacceptable. • A system that includes unconditional transfers of control to labels within other modules or explicit references to data elements in other modules introduces invisible coupling. This type of coupling is also unacceptable. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 48
    }
  },
  {
    "element_id": "80957cc7aa55dc68202251f4fdf954c8",
    "text": ") The number of different items/connections passed between modules deter- mines the complexity of an interface. Simple interfaces, which involve the passing of minimal information that is directly accessed, are best. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 48
    }
  },
  {
    "element_id": "233ffd6f1a7d3974dcb23ee13f229193",
    "text": ") The types of information transmitted between modules involves: • Data are information, which is operated upon, manipulated or changed by a module, and is essential to the functioning of a module. • Control information is any ﬂag, switch or variable that regulates the of processing. Control information causes modules to be interdependent and its use must be minimized. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 48
    }
  },
  {
    "element_id": "9579011847c821711c429be132ada313",
    "text": ") Make the module name a",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 48
    }
  },
  {
    "element_id": "663ea1bfffe5038f3f0cf667f14c4257",
    "text": "to",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 48
    }
  },
  {
    "element_id": "6234ca178001556ccd7729537db91650",
    "text": "word description of the function performed a module. It must speciﬁcally describe what the module accomplishes in respect to its super ordinate. The following ﬁgure illustrates this convention:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 48
    }
  },
  {
    "element_id": "da804ecd82b02a69030c650baccd5f3c",
    "text": "A minimally connected system includes modules with single interfaces supported by parameter passing (one entry/one exit, with return to the calling module at the next executable instruction). Minimal con",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 48
    }
  },
  {
    "element_id": "1a0e3164caa80f5cf62c6c9a7e5db405",
    "text": "nectivity is the acceptable standard. A system that contains modules with multiple entry points, alternate returns, unconditional transfer of control to a normal entry point, or combination of the three is undesirable and unacceptable. A system that includes unconditional transfers of control to labels other modules or explicit references to data elements in other modules introduces invisible coupling. This type of coupling is also unacceptable. number of different items/connections passed between modules deter",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 48
    }
  },
  {
    "element_id": "03e3a5372d4249b04a09beec58c7c136",
    "text": "the complexity of an interface. Simple interfaces, which involve the",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 48
    }
  },
  {
    "element_id": "00bd68cc1dd3d3929953ce983d81999c",
    "text": "Make the module name a 2 to 3 word description of the function performed by a module. It must speciﬁcally describe what the module accomplishes in respect to its super ordinate. The following ﬁgure illustrates this convention:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 48
    }
  },
  {
    "element_id": "3d6a7432f0c281128899861a8d5531a9",
    "text": "Figure 2.5.12-23 Module Naming Conventions",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 48
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 49
    }
  },
  {
    "element_id": "238c12bbd8e59e46d4634ccb5b715b54",
    "text": "page 39",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 49
    }
  },
  {
    "element_id": "0ec292ccee4a634cfb358408c8e663ad",
    "text": "Figure 2.5.12-24 Module Numbering 2.5.12.6.1.1(12-16-2021) Multiple Page Structure Charts (1) Multi-page charts will be necessary for most runs or subsystems. When a process is too large to be shown on a single page without crowding, portray the lower-level components of each major processing leg on separate pages. The full set of charts will model the same complete run or subsystem as a single huge chart, but this set will be much easier to update and maintain. (2) The ﬁrst page must show at least the main coordinating modules and the level modules; existence of subordinate modules must be indicated by use broken lines and page number references. The page number must be shown",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 49
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 49
    }
  },
  {
    "element_id": "37f9ee4b6c42401b0a87c553eceab641",
    "text": ") Multi-page charts will be necessary for most runs or subsystems. When a run/ process is too large to be shown on a single page without crowding, portray the lower-level components of each major processing leg on separate pages. The full set of charts will model the same complete run or subsystem as a single huge chart, but this set will be much easier to update and maintain. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 49
    }
  },
  {
    "element_id": "8822d4c793dfc88cbd4b3427bcd3b79e",
    "text": ") The ﬁrst page must show at least the main coordinating modules and the high level modules; existence of subordinate modules must be indicated by use of broken lines and page number references. The page number must be shown in the upper right-hand corner of each chart. The following ﬁgure provides an example:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 49
    }
  },
  {
    "element_id": "77975cceeb2a77a93a29266fa895ad2d",
    "text": "Figure 2.5.12-25 Multi-Page Structure Charts (3) Designate a subsequent page for each major processing leg and numbered and the continuation annotated as shown in the following",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 50
    }
  },
  {
    "element_id": "e23e6b4eb75e98b8a5a7a6336725b563",
    "text": "Figure 2.5.12-26 Multi-Page Structure Chart 1",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 51
    }
  },
  {
    "element_id": "e23e6b4eb75e98b8a5a7a6336725b563",
    "text": "Figure 2.5.12-26 Multi-Page Structure Chart 1",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 51
    }
  },
  {
    "element_id": "6d9ed13b54831ebdbf8211941b77d969",
    "text": "Figure 2.5.12-27 Multi-Page Structure Chart 2",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 52
    }
  },
  {
    "element_id": "6d9ed13b54831ebdbf8211941b77d969",
    "text": "Figure 2.5.12-27 Multi-Page Structure Chart 2",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 52
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 52
    }
  },
  {
    "element_id": "60bfbfd7ea3fb1da89ee4f1583b5a290",
    "text": ") Number the modules that are reusable throughout a run/process or between subsystems (i.e., library modules). When a run/process is large and complex, all subsequent occurrences of a reusable module must also refer back to the ﬁrst occurrence of the module. Show both numbers on the structure chart, to make it easier to locate the module speciﬁcations and the coded module since they are numerically arranged. If connectors are not drawn from the super- ordinate modules to the common modules, then the ﬁrst occurrence module number is shown in parentheses. The following ﬁgure illustrates these practices.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 52
    }
  },
  {
    "element_id": "27a72013aa2aee190b9c0b1a9743cba0",
    "text": "cor || g com.OATE | | Sefurence) oaTeW",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 52
    }
  },
  {
    "element_id": "f5b6424e2165dbdd9f2866105ca228b3",
    "text": "Figure 2.5.12-28 Module Numbering",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 52
    }
  },
  {
    "element_id": "2d9694ed0256bd8ae53bbc5e6cc06889",
    "text": "Module 1 calls Module 1.1 conditionally, based on the result of a major decision in the following ﬁgure.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 53
    }
  },
  {
    "element_id": "dd5fca413c79f316bf8120713a6b9a7a",
    "text": "Figure 2.5.12-29 Modules",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 53
    }
  },
  {
    "element_id": "ff3d6dbd67ce208df6a622d24bfca456",
    "text": "(1) Module 1 loops through calls to 1.1 and 1.2 in the example below:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 53
    }
  },
  {
    "element_id": "9e7031969535e0561be45331b5fba76a",
    "text": "Figure 2.5.12-30 Module (Iteration) 35415P (12-16-2021) Internal Revenue Manual 2.5.12.6.2.1.2",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 53
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 54
    }
  },
  {
    "element_id": "ae462d7d51158418d20dcabaefb83531",
    "text": ") This notation indicates the statements that constitute a module are written con- tiguously, that is, coded in-line, within the boundaries of another module. Module",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 54
    }
  },
  {
    "element_id": "908857837f12902a410123afa751b469",
    "text": "in the example below is actually in-line code to Module",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 54
    }
  },
  {
    "element_id": "5793032e8e2a6682dcb06fcbf216dee6",
    "text": "; it is lexically included in Module",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 54
    }
  },
  {
    "element_id": "a6be340c376a22a075eb15ba6aafccda",
    "text": "Figure 2.5.12-31 Lexical (1) Pre-existing Module Notation indicates a module developed",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 54
    }
  },
  {
    "element_id": "5834581f13981df26f072522f0178c17",
    "text": "Pre-existing Module Notation indicates a module developed or used before (i.e., noted elsewhere in the structure chart). In the example below, Module 1.1 is used elsewhere in the system and striping the module representation shows that fact.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 54
    }
  },
  {
    "element_id": "e3b0c44298fc1c149afbf4c8996fb924",
    "text": "",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 54
    }
  },
  {
    "element_id": "a447dae5c9f0717617f89fe732f7007e",
    "text": "File notation indicates a data ﬁle. It can be used when representing an internal sort ﬁle; however, its use is generally discouraged.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 54
    }
  },
  {
    "element_id": "a6e936e0b2a16273a95f28d329a50123",
    "text": "Figure 2.5.12-33 Symbol used to depict a File",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 55
    }
  },
  {
    "element_id": "a016d562788219588c9d1fc703391ca9",
    "text": "Figure 2.5.12-34 Common Environment 2.5.12.6.4(12-16-2021) Structure Chart Interface Parameters (Couples) (1) Information ﬂow between modules must consist only of the passing of param- eters. A line connecting two modules on a structure chart deﬁnes the interface between those modules; the parameters ﬂow along this interface. 2.5.12.6.4.1(12-16-2021) Interface Parameter Names (1) The names of data parameters (couples) must match those names used in the FSP whenever possible. The data ﬂow diagram names in the FSP often show modiﬁers (i.e., NAME-CONTROL-(VALID), NAME-CONTROL-(INVALID)) to represent the logical ﬂow of data. As the structure charts depict the physical ﬂow of data, only the pure data name may be shown, without illustrating any modiﬁers. (2) Make the control couples descriptive. 2.5.12.6.4.2(12-16-2021) Identifying Data and Control Parameters (1) Identify the parameters (couples) by using either the structure chart or a parameter list. Cat. No. 35415P (12-16-2021) Internal Revenue Manual 2.5.12.6.4.2",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 55
    }
  },
  {
    "element_id": "e3b0c44298fc1c149afbf4c8996fb924",
    "text": "",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 55
    }
  },
  {
    "element_id": "03875fe670506c572d600200ff2abfbe",
    "text": "NOTE: RANGE-TABIE is common (1 sad 3).",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 55
    }
  },
  {
    "element_id": "30e5a817f76d3941b277aa508cf0760e",
    "text": "Figure 2.5.12-34 Common Environment",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 55
    }
  },
  {
    "element_id": "96674ccd5d0af492d014e1d51079c6f2",
    "text": "Information ﬂow between modules must consist only of the passing of param- eters. A line connecting two modules on a structure chart deﬁnes the interface between those modules; the parameters ﬂow along this interface.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 55
    }
  },
  {
    "element_id": "d026d9987c543a4c357d28c9d18f87ae",
    "text": "The name or identiﬁcation of the parameter appears beside the arrow. The following ﬁgure depicts a structure chart with labeled parameters.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "8ab502646827759be6236a437e378c89",
    "text": "\"-o ge o (|GETX TRANSFORM PuTYFlours 25.13-08 Stuchure Chart Parsmeter let",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "1f5be66894e5ef6a6919e1f6499a7c1e",
    "text": "Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "58986c0c69404e292ffb68ab0ae4b3ed",
    "text": "Structure Chart Parameter list (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "e76c916c3a84d6160100249407d15cf3",
    "text": ") To use a parameter list:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "c48910afdd8c350925553d9d378b10f2",
    "text": "Number each module connector and create a table listing the module connector numbers and the related input and output parameters. Identify a control parameter by underlining its name in the parameter table.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "ac09b2d9927d0a3d98c30d0c5a0c0081",
    "text": "Sparingly use the parameter list, a labeled parameter arrow along the interface line can be comprehended more quickly than a numerical reference to an entry in a table. To avoid ﬂipping back and forth among the pages of the documentation, the parameter list must appear on the same page as the related portion of the structure chart. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "908198b97aae9da64868adcaef95239f",
    "text": ") If the number of parameters or the length of the parameter names clutters the structure chart, then a parameter list may be particularly useful. Exhibit",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "76446f1f54138772f77206b765c9aaa2",
    "text": "provides an example of page",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "1d0e71d52e58f5047bcb60af9e908a12",
    "text": "of a structure chart using a parameter list. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "4b28941f9cc54051e7a44787a071faa4",
    "text": ") A stand-alone system sort or a straightforward internal sort that is shown as separate run/process on a technical diagram must not be displayed on a structure chart unless it is an integral part of the overall program design.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "49ab00cb61d79f0a3129e7a68b3987ed",
    "text": "Figure 2.5.12-36 Structure Chart Parameter list",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "c48910afdd8c350925553d9d378b10f2",
    "text": "Number each module connector and create a table listing the module connector numbers and the related input and output parameters. Identify a control parameter by underlining its name in the parameter table.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "b03a487970c265f736429afe9351be6a",
    "text": "Sparingly use the parameter list, a labeled parameter arrow along the interface line can be comprehended more quickly than a numerical reference to an entry in a table. To avoid ﬂipping back and forth among the pages of the documentation, the parameter list must appear on the same page as the related portion of the structure chart.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "a022388ae381dc6d5447a8aabf38bb4d",
    "text": "If the number of parameters or the length of the parameter names clutters the structure chart, then a parameter list may be particularly useful. Exhibit 2.5.12- 2 provides an example of page 1 of a structure chart using a parameter list.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "a29d4842c312b27bd7677833c68d088f",
    "text": "A stand-alone system sort or a straightforward internal sort that is shown as a separate run/process on a technical diagram must not be displayed on a structure chart unless it is an integral part of the overall program design.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 56
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "daa3d5665623a687b36f2304384cf14a",
    "text": ") Show the stand-alone system sort or a straightforward internal sort on the structure chart in order to present a coherent representation of the process. Show Sort input or output ﬁles on a structure chart for clarity. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "2c6724b738204157dfbd76a26aa616da",
    "text": ") A stand-alone system sort or a straightforward internal sort must be docu- mented in the run description. List (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "e60d9ee88cc532d4c34a9704f688c421",
    "text": ") In large and complex projects, there may be a need for an audit trail between the modules of a structure chart and the process speciﬁcations of a functional speciﬁcation package. In this case, attach a list cross-referencing each indi- vidual module on a structure chart to the corresponding process speciﬁcations in the functional speciﬁcation package that describe the transformation of data parameters entering and exiting that module. See Exhibit",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "faf64389a42d662e20dc4a78313b2958",
    "text": ") Include a cross-reference list when: • A project manager determines that it is necessary for project control purposes or that it would signiﬁcantly enhance the usability of project documentation. • The cross-reference is requested by quality review (i.e., Internal Audit, Quality Assurance, testing personnel). Chart Module (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "74a8441fcd0ded12630ee99f1be3ac82",
    "text": ") Module speciﬁcations provide the link between structure charts and the coding of structured programs. In effect, the structure chart shows the architecture a system, not the sequence of procedures, which transform system input to system output. However, in order to proceed with programming, we must know the transform from input to output affected by each module of a structure When a module is invoked, a module speciﬁcation deﬁnes what happens. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "9f7cc29af38e54b6458524210b62260d",
    "text": ") There are two types of modules that comprise a structure chart: data transfor- mation modules and control modules. Although speciﬁcation of the internal logic of a module is generally considered a programming task, there is consid- erable overlap between the design and programming activities at this stage, just as there was between analysis and design when packaging the data ﬂow diagrams. It is therefore necessary to specify procedural detail for both data transformation and control modules. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "f66fbbe24d4f8c7cc0ec6190ab3f79c4",
    "text": ") Pseudocode pertains to creating a non-programming language outline of your code’s intent, and is similar to structured English. It is a type of module speciﬁ- cation that describes in code like terms how to do the transform effected by module. As pseudocode is much closer to actual code than structured English, it allows less margin for misinterpretation and must be written using only the three basic constructs of programming: sequence, selection, and iteration. speciﬁed logic for each module must not be oriented to any speciﬁc program- ming language. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "4ec9ae04f206571f7c8eb84860242067",
    "text": ") Pseudocode ensures that the logic of every module is structured. Pseudocode can be shown graphically to help display the control structure while depicting program logic. Graphic pseudocode is easily maintained, more meaningful, does not display “statements” The main goal of pseudo code is to explain speciﬁcally each line of a program must perform; therefore, the code construc- tion phase becomes easier for the programmer/developer. Pseudocode is useful for the following: Techniques and Deliverables",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "3660315a9af3df255d8f19ab077e4797",
    "text": "page",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "87d2a82689ec9cb6b074c23bf4d2a45e",
    "text": "P (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "6726c0a6ddbc7e77d189e9318f57a047",
    "text": ") Internal Revenue Manual",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "788347c5e163fc1d566430f9567b9a64",
    "text": "marked with a # Use Only",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "af87644d6994de24875bab0b8e177670",
    "text": "A project manager determines that it is necessary for project control purposes or that it would signiﬁcantly enhance the usability of project documentation. The cross",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "9628aaf95028f5f13ce14b99a7f8194e",
    "text": "reference is requested by quality review (i.e., Internal Audit, Quality Assurance, testing personnel).",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "f186d12ee3d11a8a26043053730a12d1",
    "text": "Quality Assurance, testing personnel). (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "eef56b7ff72c9df088bae71f525ec297",
    "text": ") Module speciﬁcations provide the link between structure charts and the coding of structured programs. In effect, the structure chart shows the architecture of a system, not the sequence of procedures, which transform system input to system output. However, in order to proceed with programming, we must know the transform from input to output affected by each module of a structure chart. When a module is invoked, a module speciﬁcation deﬁnes what happens. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "9f7cc29af38e54b6458524210b62260d",
    "text": ") There are two types of modules that comprise a structure chart: data transfor- mation modules and control modules. Although speciﬁcation of the internal logic of a module is generally considered a programming task, there is consid- erable overlap between the design and programming activities at this stage, just as there was between analysis and design when packaging the data ﬂow diagrams. It is therefore necessary to specify procedural detail for both data transformation and control modules. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "fd333654554e1396abf17d7ece692736",
    "text": ") Pseudocode pertains to creating a non-programming language outline of your code’s intent, and is similar to structured English. It is a type of module speciﬁ- cation that describes in code like terms how to do the transform effected by a module. As pseudocode is much closer to actual code than structured English, it allows less margin for misinterpretation and must be written using only the three basic constructs of programming: sequence, selection, and iteration. The speciﬁed logic for each module must not be oriented to any speciﬁc program- ming language. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "78dbc40678d659e17ed19e0c7589e51c",
    "text": ") Pseudocode ensures that the logic of every module is structured. Pseudocode can be shown graphically to help display the control structure while depicting program logic. Graphic pseudocode is easily maintained, more meaningful, does not display “statements” The main goal of pseudo code is to explain what speciﬁcally each line of a program must perform; therefore, the code construc- tion phase becomes easier for the programmer/developer. Pseudocode is useful for the following:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "fd333654554e1396abf17d7ece692736",
    "text": ") Pseudocode pertains to creating a non-programming language outline of your code’s intent, and is similar to structured English. It is a type of module speciﬁ- cation that describes in code like terms how to do the transform effected by a module. As pseudocode is much closer to actual code than structured English, it allows less margin for misinterpretation and must be written using only the three basic constructs of programming: sequence, selection, and iteration. The speciﬁed logic for each module must not be oriented to any speciﬁc program- ming language. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "18a26358f122fdc86d12016808ea52a7",
    "text": ") Pseudocode ensures that the logic of every module is structured. Pseudocode can be shown graphically to help display the control structure while depicting program logic. Graphic pseudocode is easily maintained, more meaningful, but does not display “statements” The main goal of pseudo code is to explain what speciﬁcally each line of a program must perform; therefore, the code construc- tion phase becomes easier for the programmer/developer. Pseudocode is useful for the following:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 57
    }
  },
  {
    "element_id": "ef84bc74a229280ffd8f5a26032771ed",
    "text": "a. To describe how an algorithm must work. b. To explain the coding process to less-technical users. c. To design code as a team for solving complex problems. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "ad80897cb8f54c3ca72294ea5225174c",
    "text": ") The following is the recommended strategy when using pseudocode: a. Implement pseudocode before the actual coding process. b. Write using simple terminology. c. Do not write source code, but write your thoughts of what the program must perform. d. Limit pseudocode statements to one for each line. e. Use capitalization for all keywords on each line. f. List your pseudocode in the proper order that must be executed for your coding project. g. Make sure the pseudocode can easily be translated into a programing language. h. Ensure the pseudocode describes all processes related to the program. i. Implement peer-reviews for rechecking your pseudocode for readability and clarity. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "c745de45e2a2d305461d69a8ea331aab",
    "text": ") For control and data transformation modules, pseudocode will be developed for each module on the structure chart. Either a Structured English, Warnier- Orr, or Nassi-Shneiderman format may be used for the pseudocode. This begins in the design stage and, by the programming stage, must be completed. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "0bab2b8b4b9fe8a0761cc20aa5ef8d19",
    "text": ") Do not write program source code for a module until pseudocode for that module has been completed. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "eb2b1dbf33d6e844c23f668ac8701feb",
    "text": ") Begin the development of pseudocode (especially for high level modules) during the design stage. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "445af43c1220178816eacfd0764dc568",
    "text": ") Once the pseudocode for a given module is complete, source coding may begin for that module, (i.e., higher level modules may be source coded before the pseudocode for the lower levels has been developed). (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "eeb69d848a39a1574486fd9b9e6f6b70",
    "text": ") Develop pseudocode for any remaining modules during the programming stage. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "40578c1be57e4f303b65682238a86172",
    "text": ") Use the same form of pseudocode for all modules in any given system. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "d05ff9dd29f5d9146b5990eb25aa7988",
    "text": ") The following header information must be present on all pseudocode: • Programmer/Designer - Person responsible for the logic of the module. • Date - The date of origination or revision. • Program - Name of the program that contains this module. • Module Number - The number assigned to the module on the structure chart. • Module Name - Name of the module on the structure chart. • Input Parameters - The parameters passed to this module from its invoking module. • Output Parameters - The parameters passed by this module to its invoking module. • Local Variables - Variables, ﬂags, switches, work areas used only by this module. Internal Revenue Manual Cat. No.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "87d2a82689ec9cb6b074c23bf4d2a45e",
    "text": "P (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "55e41916be91aca2966d0db044f2ad9a",
    "text": ") Any line marked with",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "42b63644522fb0544adae8977e7a7ad5",
    "text": "Implement pseudocode before the actual coding process. Write using simple terminology. Do not write source code, but write your thoughts of what the program must perform. Limit pseudocode statements to one for each line. Use capitalization for all keywords on each line. List your pseudocode in the proper order that must be executed for your coding project. Make sure the pseudocode can easily be translated into a programing language. Ensure the pseudocode describes all processes related to the program. Implement peer",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "48d400e2144d66891f2f9c5e99cedb42",
    "text": "reviews for rechecking your pseudocode for readability and clarity.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "128de3287c7a5dadd1ca4dd9432969de",
    "text": "Programmer/Designer",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "2183023eedfff23d9f7c5b9d1879f9dd",
    "text": "Person responsible for the logic of the module. Date",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "d0bb9da3d1b885088a3c40c16fd370a3",
    "text": "The date of origination or revision. Program",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "993cab6e383973c1312be50e470275fe",
    "text": "Name of the program that contains this module. Module Number",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "6f528f948d8a9dca31214aa9034cc6f4",
    "text": "The number assigned to the module on the structure chart. Module Name",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "c6007e253ba88c07914ebe6cee7f1acd",
    "text": "Name of the module on the structure chart. Input Parameters",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "6439d07dd2eacc4a5232749c2991768e",
    "text": "The parameters passed to this module from its invoking module. Output Parameters",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "08978768cf61617ebd982bba9ce2547a",
    "text": "The parameters passed by this module to its invoking module. Local Variables",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "0f6b3519a670c78b6dade0873e7a775c",
    "text": "Variables, ﬂags, switches, work areas used only by this module.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 58
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "8e597d3e1a47669b3918cc0b4a84c435",
    "text": "• Function - Brief statement describing the function of the module. This must not be a detailed description of the module logic or its internal cessing. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "4c9460cfb79f33bf00dcd811f94ce8e9",
    "text": ") Only develop pseudocode for reusable (common) modules to be developed the ﬁrst occurrence of the module on the structure chart. The pseudocode must contain cross-references to all other occurrences of the module within process/run. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "46149fcd906a6d51fc372226859a6e25",
    "text": ") For modules that are reused by numerous processes/runs, the pseudocode must also provide a cross-reference to the organization responsible for main- taining it. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "db5d01b226a488d85f349b322d660a13",
    "text": ") Organize the pseudocode in run-module sequence number and maintain it the project library. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "631fd840aa4bb5e7c0a6ec6b925eeffc",
    "text": ") Package the pseudocode developed for common modules with other pseudo- code for the system, or it may be packaged as a separate document. If maintained as a separate document, it must by easily accessible and readily available to all members of a project team. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "ac2db02631ee44a9f5da4d10ed02d7f8",
    "text": ") Retain the most current pseudocode as part of the project documentation in the project library. Before coding changes are made to an existing module, update or redo the pseudocode to reﬂect any logic changes that will occur the module. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "5925e48163a7e386690b96960dcf0463",
    "text": ") At the end of analysis, partition a single set of data ﬂow diagrams into related groups of processes; manual and automated boundaries are established i.e., (data ﬂow diagrams are packaged). This gives the designer a starting point the development of the structure charts. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "b661d033226fb5b362f9458af50c90d0",
    "text": ") Once the structure charts are completed, they must be reevaluated to see if further decomposing and/or packaging is necessary to meet the criteria of speciﬁc hardware/operating system. Estimate the size of each module. Based on memory requirements of a particular structure, as well as other characteris- tics such as logical execution patterns and overall system efficiency, it may desirable or necessary to partition a structure chart into smaller units (for pilation and/or execution purposes). Determine if further packaging is necessary. Use the criteria for packaging to determine which modules must grouped together and which must be isolated. In general, the following guide- lines must apply: • Include groups of modules that are frequently invoked or executed, close to one another in the same program. • Deﬁne groups of modules so that splitting of preferred groupings by program boundaries is minimized without bringing the size of the program above the allowable maximum for the speciﬁc hardware system. This grouping will result in the most efficient packaging for given structure within given memory constraints. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "7fff1d3adf2941168b8a364ea853a555",
    "text": ") Figure",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "3973e022e93220f9212c18d0d0c543ae",
    "text": "-",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "133b85bfdfe405dbe0e517c9596bd091",
    "text": "speciﬁes grouping criteria for packaging.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "bc07977ecd0ff4ecf2ae868c653d6420",
    "text": "Function - Brief statement describing the function of the module. This must not be a detailed description of the module logic or its internal pro- cessing.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "c438ecb8123729ddb38f9b63af84fcc9",
    "text": "Include groups of modules that are frequently invoked or executed, close to one another in the same program. Deﬁne groups of modules so that splitting of preferred groupings by program boundaries is minimized without bringing the size of the program above the allowable maximum for the speciﬁc hardware system. This grouping will result in the most efficient packaging for the given structure within given memory constraints.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "fd80cd952449d68e0e9a53ade4e28bd2",
    "text": "(3) Figure 2.5.12- 21 speciﬁes grouping criteria for packaging.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 59
    }
  },
  {
    "element_id": "1c3ba6caeb99793190d8faed91817045",
    "text": "Grouping Criteria for Packaging Grouping Criteria Priority Rules Volume (if known). Include in the same program modules with high volume of access on connecting references (many activities or many items passed). High volume takes precedence over low volume. Iterations. Include in the same program modules connected by iterated references (loops). Inner loops take precedence over outer loops; loops nested within a module take precedence over nesting by subordination. If volume criteria is known, then this criteria takes precedence over iteration. Frequency. Include in the same program modules with high frequency of access on connect- ing references (frequent transfers of control or data. High frequency takes precedence over lower frequency. If known, volume and/or iteration are pref- erable. Interval. Include in the same program, as either the super ordinate or subordinate, any module with short interval of time between activation. Short execution time has prece- dence over long execution time. This is a low priority criterion. Adjacency. Include the same program modules activated adjacent in time, or using the same data. Very low priority rule, used only when other criteria are not available.",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 60
    }
  },
  {
    "element_id": "89016af3b3fabf02c93f90016f75fd47",
    "text": "program modules with high frequency of access on connect- ing references (frequent transfers of control or data.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 60
    }
  },
  {
    "element_id": "afb4e51216de01b0a7cde3898530ae32",
    "text": "The following items are isolation criteria for packaging:",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 60
    }
  },
  {
    "element_id": "594050595d560404a138cda877c25736",
    "text": "Optional Functions: Separate optional function modules into distinct programs.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 60
    }
  },
  {
    "element_id": "8b12507783d5becacbf2ebe5b01a6002",
    "text": "One",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 60
    }
  },
  {
    "element_id": "2bac0294317778d85005d9887aa39578",
    "text": "shot Functions: Separate modules that are minimally coupled and used only once into distinct programs (e.g., initialization).",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 60
    }
  },
  {
    "element_id": "4bc3d0fe03b5c497befa2144e19eb53a",
    "text": "Sorts: Separate sort function modules into distinct programs; separate modules applied on input or output sides of a sort into separate programs; the criteria for grouping modules may take priority.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 60
    }
  },
  {
    "element_id": "a3d3046c238c6881ed49c5bfc7f50c5e",
    "text": "Data: Separate modules into programs where any resulting intermediate ﬁles between programs will be of lowest volume and simplest data structure. The criteria for grouping modules may take priority.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 60
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 60
    }
  },
  {
    "element_id": "f1d62ab6e74e9a43aacbedb346c57268",
    "text": ") When addressing operator messages, divide all operator messages into infor- mation messages and console messages. Only display those messages, which require operator intervention or affect the continued operation of a run stream on the console and, if a run control print log is available, then route all other messages to this log. Keep operator messages to a minimum and make sure all of them are documented.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 60
    }
  },
  {
    "element_id": "3351897a5db6ea82ff0ee305e9a9350e",
    "text": "After structure charts are completed and pseudocode writing has begun, begin development of the interface between the design and programming.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "c9866ec37f7b38c27b55ff15dd85c0cc",
    "text": "The designers and programmers work together at this point to ﬁnalize the design of individual modules prior to the start of actual logic diagramming and coding. There are different points of view as to when to begin coding the program modules as noted below:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "32ebb1abcc1c601ceb9c4e3c4faba0ca",
    "text": "(",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "2154cc81864c1ef373f836093fafad2c",
    "text": ") The designers and programmers work together at this point to ﬁnalize the design of individual modules prior to the start of actual logic diagramming and coding. There are different points of view as to when to begin coding the program modules as noted below: • Achieve maximum cohesion and factoring, and minimum coupling by completing the structure chart and the pseudocode prior to the actual coding of each module. Although the design is considered complete at this point, the most important advantage of this approach is that the design is more easily altered and reﬁned before code is written. Modules can be added to, or removed from, the structure chart as a result of speciﬁcation changes in the FSP or programming consider- ations. Such changes must not involve a major redesign of the system. • It may, however, be more expedient to develop source code for the higher levels of the structure chart before pseudocode is developed for the lower levels. (",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "67498fb460411cb400955a23ac047384",
    "text": ") The software development lifecycle has four steps:",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "7270fe135cf9beabc996949799ee7d8c",
    "text": "Requirements Gathering and Analysis: Create a Problem Statement: Implement the initial problem statement in accordance with the project’s IRS business process requirement, and ensure it is included in your project charter. Update the problem statement during the life of the project when it is necessary. Use Case Generation: Use cases capture the goal of an action, and a trigger event that starts a process including: inputs, outputs, errors, and exceptions. Use cases are often written in the form of an actor. Feature List Creation: A set of program features that you will derive from the problem statement, and will consist of your initial requirements.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "7c7dc206f30ca299f2b5adef539b4980",
    "text": "Design: Breaking the problem into subsystems or modules Mapping your features, subsystems, and use cases to domain objects Creating abstractions Identifying the programs’ objects, methods, and algorithms",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "f555a641f2da52b318a9206b52160243",
    "text": "Implementation and Testing: Implement the iteration Test the iteration",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "a22e50036db3ffe337331b3627f31dbb",
    "text": "Release, Maintenance, and Evolution: Perform the ﬁnal acceptance testing and release requirements.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "af87c2d7bd5e4a000350e0bf4bac4c3e",
    "text": "Achieve maximum cohesion and factoring, and minimum coupling by completing the structure chart and the pseudocode prior to the actual coding of each module. Although the design is considered complete at this point, the most important advantage of this approach is that the design is more easily altered and reﬁned before code is written. Modules can be added to, or removed from, the structure chart as a result of speciﬁcation changes in the FSP or programming consider",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "b3e26882c1fcea7261d9e516b197f39e",
    "text": "ations. Such changes must not involve a major redesign of the system. It may, however, be more expedient to develop source code for the higher levels of the structure chart before pseudocode is developed for the lower levels.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "4b8d309941bc621923ef16bfd78f3065",
    "text": "Requirements Gathering and Analysis: Create a Problem Statement: Implement the initial problem statement in accordance with the project’s IRS business process requirement, and ensure it is included in your project charter. Update the problem statement during the life of the project when it is necessary. Use Case Generation: Use cases capture the goal of an action, and a trigger event that starts a process including: inputs, outputs, errors, exceptions. Use cases are often written in the form of an actor. Feature List Creation: A set of program features that you will derive from the problem statement, and will consist of your initial requirements.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "7c7dc206f30ca299f2b5adef539b4980",
    "text": "Design: Breaking the problem into subsystems or modules Mapping your features, subsystems, and use cases to domain objects Creating abstractions Identifying the programs’ objects, methods, and algorithms",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "f555a641f2da52b318a9206b52160243",
    "text": "Implementation and Testing: Implement the iteration Test the iteration",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "a22e50036db3ffe337331b3627f31dbb",
    "text": "Release, Maintenance, and Evolution: Perform the ﬁnal acceptance testing and release requirements.",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 61
    }
  },
  {
    "element_id": "33c1e29902d678cbcff13d561dbfd825",
    "text": "This Page Intentionally Left Blank",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 62
    }
  },
  {
    "element_id": "7c239ccfe78cdf8290d4ad7e2b60a8fc",
    "text": "Exhibit 2.5.12-1 (12-16-2021) Example of a Structure Chart",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 63
    }
  },
  {
    "element_id": "e3b0c44298fc1c149afbf4c8996fb924",
    "text": "",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 63
    }
  },
  {
    "element_id": "9e112e77de6c3fe2a06bcdb14841ab99",
    "text": "Exhibit 2.5.12-2 (12-16-2021) Example of Page 1 of a Structure Chart using a Parameter Table",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 64
    }
  },
  {
    "element_id": "9ccdb856a6db1f45b03d3fcdc7ec5b45",
    "text": "TRMRs Te o ot: RO TSRS BTVAL TRANS 2,B P— ANTIED TN MASTER RNoNAT AN i,3 |ntcuED NS MASTER ReC | RDATED MASTER REC§ [N sTeR REC3 | MASTERREC, NONATCH.vyo | VALD TS G MASTER REC | MATCHED TRANS MASTER REC$ |VAHD TR3 | VATOHED TONS MASTIRREC | PDATEDMASTER REC5 AR TR RECo | VAL TRANSREC NOMATCHTRANS REPORT R1 oM RS REroR TR13| DEAITSECTION MOVEX BALKSCE | DEBI SECTION, MONEY-TS DATA DRLANGE Lo POSTNG DATEs | CKEDISECTION MoNeY. | CREDIT SECTION, HONEY-AL AN AR e e pATE",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 64
    }
  },
  {
    "element_id": "07ca9f6aad55c650c08c64b2fd18067a",
    "text": "Design Techniques and Deliverables 2.5.12",
    "type": "Title",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 65
    }
  },
  {
    "element_id": "a53a13d3649c48baf4c9a1160d7cdc90",
    "text": "Exhibit 2.5.12-2 (Cont. 1) (12-16-2021) Example of Page 1 of a Structure Chart using a Parameter Table",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 65
    }
  },
  {
    "element_id": "4ade63f6eeccecc71f2a60a87ce9f6a8",
    "text": "Parameter Table No. Input Output 1. PURPOSELY LEFT BLANK VALID-TRANS-REC, END-OF-VALID-TRANS- IND 2. VALID-TRANS-REC MATCHED-TRANS-MASTER-REC, NO- MATCH-TRANS-IND 3. MATCHED-TRANS-MASTER-REC UPDATED-MASTER-REC 4. UPDATED-MASTER-REC PURPOSELY LEFT BLANK 5. TRANS-KEY MASTER-REC, NO-MATCH-TRANS-IND 6. VALID-TRANS-REC, MASTER-REC MATCHED-TRANS-MASTER-REC 7. VALID-TRANS-REC PURPOSELY LEFT BLANK 8. MATCHED-TRANS-MASTER-REC UPDATED-MASTER-REC 9. UPDATED-MASTER-REC PURPOSELY LEFT BLANK 10. VALID-TRANS-REC NO-MATCH-TRANS-REPORT-REC 11. NO-MATCH-TRANS-REPORT-REC PURPOSELY LEFT BLANK 12. DEBIT-SECTION, MONEY-BALANCE, TRANS- DATA DEBIT-SECTION, MONEY-BALANCE, LAST- POSTING-DATE 13. CREDIT-SECTION, MONEY-BALANCE, TRANS-DATA CREDIT-SECTION, MONEY-BALANCE, LAST-POSTING-DATE",
    "type": "UncategorizedText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 65
    }
  },
  {
    "element_id": "238353e86857aa2b8cdc824a83ae6424",
    "text": "W Systomta: Responsibe Operationat Date:o Organiaaton: Revison Date:(Ran Number)(Scane Chat Nane)@ Cross Refersne List@ CorresponingModule Number ProcessSpecfcaton& FSp © Spectn)o 19 00h 199 10i > iz12 I 2o 421321 19 13022 19 131221 i 150222 I 1315 g 22B Ee B",
    "type": "FigureCaption",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 66
    }
  },
  {
    "element_id": "87eefc18c8c3cacf280f7d8bb7a694cc",
    "text": "‘The madule, FSP, and process specification numbers are included in this exhibit anly t0 provide sn©xmmple. The below mrmbered motzs xplein the mumbers n parcnthcscs.",
    "type": "NarrativeText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 66
    }
  },
  {
    "element_id": "9cf13a2840f32f668214abde243380b7",
    "text": "Notes:o@®@©The henderforthe Cross: Reerence st shuldbeidnicl ot esder o thesajectsicteechar“The Sttt Char Nam shold e th e of modsle",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 66
    }
  },
  {
    "element_id": "2754581c02e1e4818de58c3aa7f5327c",
    "text": "the St Chirt,A shown i the abon cxample, in i rde, it cach e o h St Cha,Lis e FSP amber i which thecomesponding procss spciicuions i conanec.il asocated specfeaions conaned i th FSP st",
    "type": "ListItem",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 66
    }
  },
  {
    "element_id": "e658b65e7f022be952cec1a58a98ee75",
    "text": "Acronym Deﬁnition GOF Gang of Four IEEE-SA Institute of Electrical and Electronics Engineers Standards Association (IEEE-SA) FISMA Federal Information Security Modernization Act FOIA Freedom of Information Act IMF Individual Master File SRS Software Requirement Speciﬁcation SSDF Secure Software Development Framework",
    "type": "UncategorizedText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 67
    }
  },
  {
    "element_id": "ad19c0dd93f5dc8c46f1185caa98c55f",
    "text": "Terms/Deﬁnitions Terms Deﬁnition Algorithm An algorithm is step-by-step procedure for solving a problem. Architecture Description Languages A language that provides syntax and semantics for deﬁning a software architecture. The notation speciﬁcation provides features for modeling a software system’s conceptual architecture. Abstraction Abstraction is a tool that enables a designer to consider a component at a abstract level without the concerns of the internal details of the implementation. Inheritance Inheritance is a mechanism that permits new classes to be created out of existing classes by extending and reﬁning its capabilities. Interface Software interconnections that allow a device, program, or a person to interact. Object Design A design model is developed based on both the models developed in the system analysis phase, and the architecture designed in the system design phase. Object Model Displays the elements in a software application in terms of objects. Refactor A systematic process of improving code without creating new function- ality. Refactoring can transform unorganized code into clean code and simple design. Requirements Visualization Methodology An iterative process of collaboration, design, and feedback. Simulations Simulations are models that imitate the proposed product or software solution. Simulations can be low, medium, or high in ﬁdelity, but users are able to interact with the product.",
    "type": "UncategorizedText",
    "metadata": {
      "filename": "zips/irm02-005-012--2021-12-16.pdf",
      "page_number": 68
    }
  }
]